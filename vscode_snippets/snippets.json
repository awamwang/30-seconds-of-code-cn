{
  "all": {
    "prefix": "30s_all",
    "body": [
      "const all = (arr, fn = Boolean) => arr.every(fn);"
    ],
    "description": "Returns `true` if the provided predicate function returns `true` for all elements in a collection, `false` otherwise.\n\n如果给定集合中的所有元素都使给定的断言函数返回`true`，则整体返回`true`；否则返回`false`。\n\nUse `Array.prototype.every()` to test if all elements in the collection return `true` based on `fn`.\nOmit the second argument, `fn`, to use `Boolean` as a default.\n\n使用`Array.prototype.every()` 把集合中所有元素都传给`fn`来验证是否都返回`true` 。不传第二个参数`fn`，则使用默认的`Boolean`（布尔型的构造函数）作为默认值。\n"
  },
  "allEqual": {
    "prefix": "30s_allEqual",
    "body": [
      "const allEqual = arr => arr.every(val => val === arr[0]);"
    ],
    "description": "Check if all elements in an array are equal.\n\n判断是否数组中的所有元素都相等。\n\nUse `Array.prototype.every()` to check if all the elements of the array are the same as the first one.\nElements in the array are compared using the strict comparison operator, which does not account for `NaN` self-inequality.\n\n使用`Array.prototype.every()` 来判断是否数组的所有元素都等于数组的第一个元素。\n"
  },
  "any": {
    "prefix": "30s_any",
    "body": [
      "const any = (arr, fn = Boolean) => arr.some(fn);"
    ],
    "description": "Returns `true` if the provided predicate function returns `true` for at least one element in a collection, `false` otherwise.\n\n集合中至少一个元素被提供的断言函数作用后返回`true`，则整体返回`true`；否则返回`false`。\n\nUse `Array.prototype.some()` to test if any elements in the collection return `true` based on `fn`.\nOmit the second argument, `fn`, to use `Boolean` as a default.\n\n使用`Array.prototype.some()`来验证集合中是否有元素被提供的断言函数`fn`作用后返回`true` 。不传第二个参数`fn`，则使用默认的`Boolean`（布尔型的构造函数）作为默认值。\n"
  },
  "approximatelyEqual": {
    "prefix": "30s_approximatelyEqual",
    "body": [
      "const approximatelyEqual = (v1, v2, epsilon = 0.001) => Math.abs(v1 - v2) < epsilon; // 程序中比较近似相等的通用思路，epsilon可以被看做一个比较精度"
    ],
    "description": "Checks if two numbers are approximately equal to each other.\n\n检查两个数是否近似相等。\n\nUse `Math.abs()` to compare the absolute difference of the two values to `epsilon`.\nOmit the third parameter, `epsilon`, to use a default value of `0.001`.\n\n使用`Math.abs()`计算两个值的差的绝对值，比较它和`epsilon`的大小。如果不传第三个参数`epsilon`，使用默认值`0.001`。\n"
  },
  "arrayToCSV": {
    "prefix": "30s_arrayToCSV",
    "body": [
      "const arrayToCSV = (arr, delimiter = ',') =>",
      "  arr",
      "    .map(v => v.map(x => (isNaN(x) ? `\"${x.replace(/\"/g, '\"\"')}\"` : x)).join(delimiter))",
      "    .join('\\n'); // 先把数字转字符串；再把每行的字符串拼接；再把每一行拼接（其中的“\"”按照CSV的规则进行转义）"
    ],
    "description": "Converts a 2D array to a comma-separated values (CSV) string.\n\n把二维数组转换为点分形式（CSV）字符串。\n\nUse `Array.prototype.map()` and `Array.prototype.join(delimiter)` to combine individual 1D arrays (rows) into strings.\nUse `Array.prototype.join('\\n')` to combine all rows into a CSV string, separating each row with a newline.\nOmit the second argument, `delimiter`, to use a default delimiter of `,`.\n\n使用`Array.prototype.map()`和`Array.prototype.join(delimiter)`把单独的一维数组（行）连接成字符串。使用`Array.prototype.join('\\n')`来把所有行连接成CSV字符串，每行使用换行符分隔。如果不传第二参数`delimiter`，使用`,`作为默认值。\n"
  },
  "arrayToHtmlList": {
    "prefix": "30s_arrayToHtmlList",
    "body": [
      "const arrayToHtmlList = (arr, listID) =>",
      "  (el => (",
      "    (el = document.querySelector('#' + listID)),",
      "    (el.innerHTML += arr.map(item => `<li>${item}</li>`).join(''))",
      "  ))();"
    ],
    "description": "Converts the given array elements into `<li>` tags and appends them to the list of the given id.\n\n把给定的数组元素转换为`<li>`标签，并把他们追加到给定id的list标签中。\n\nUse `Array.prototype.map()`, `document.querySelector()`, and an anonymous inner closure to create a list of html tags.\n\n使用`Array.prototype.map()`，`document.querySelector()`和一个匿名闭包来创建一个html的list标签。\n"
  },
  "ary": {
    "prefix": "30s_ary",
    "body": [
      "const ary = (fn, n) => (...args) => fn(...args.slice(0, n));"
    ],
    "description": "Creates a function that accepts up to `n` arguments, ignoring any additional arguments.\n\n创建一个最多`n`个参数的函数，它会忽略其他参数。\n\nCall the provided function, `fn`, with up to `n` arguments, using `Array.prototype.slice(0, n)` and the spread operator (`...`).\n\n使用`Array.prototype.slice(0, n)`和展开操作符(`...`)提取最多`n`个参数，传给`fn`并调用。\n"
  },
  "atob": {
    "prefix": "30s_atob",
    "body": [
      "const atob = str => Buffer.from(str, 'base64').toString('binary'); // 不支持中文；Buffer是Node中处理编码转换的以一个好工具；"
    ],
    "description": "Decodes a string of data which has been encoded using base-64 encoding.\n\n解码一个被base-64编码的字符串（Base64解码）。\n\nCreate a `Buffer` for the given string with base-64 encoding and use `Buffer.toString('binary')` to return the decoded string.\n\n用base-64为给定的字符串创建一个`Buffer`，使用`Buffer.toString('binary')`来返回解码后的字符串。\n"
  },
  "attempt": {
    "prefix": "30s_attempt",
    "body": [
      "const attempt = (fn, ...args) => {",
      "  try {",
      "    return fn(...args);",
      "  } catch (e) {",
      "    return e instanceof Error ? e : new Error(e);",
      "  }",
      "};"
    ],
    "description": "Attempts to invoke a function with the provided arguments, returning either the result or the caught error object.\n\n尝试用给定的参数执行一个函数，返回结果或者捕获一个错误对象。\n\nUse a `try... catch` block to return either the result of the function or an appropriate error.\n\n使用`try... catch`块返回函数结果或者一个合适的错误。\n"
  },
  "average": {
    "prefix": "30s_average",
    "body": [
      "const average = (...nums) => nums.reduce((acc, val) => acc + val, 0) / nums.length;"
    ],
    "description": "Returns the average of two or more numbers.\n\n返回两个或多个数的平均值。\n\nUse `Array.prototype.reduce()` to add each value to an accumulator, initialized with a value of `0`, divide by the `length` of the array.\n\n使用`Array.prototype.reduce()`来把每个值添加到累加器中，初始累加值为`0`，再除以数组的长度`length`。\n"
  },
  "averageBy": {
    "prefix": "30s_averageBy",
    "body": [
      "const averageBy = (arr, fn) =>",
      "  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => acc + val, 0) /",
      "  arr.length;"
    ],
    "description": "Returns the average of an array, after mapping each element to a value using the provided function.\n\n把每个元素使用给出的函数映射到一个值，返回值数组的平均值。\n\nUse `Array.prototype.map()` to map each element to the value returned by `fn`, `Array.prototype.reduce()` to add each value to an accumulator, initialized with a value of `0`, divide by the `length` of the array.\n\n使用`Array.prototype.map()`来把每个元素映射到`fn`返回的值，使用`Array.prototype.reduce()`来把每个返回的值添加到累加器中，初始累计值为`0`，最后除以数组的长度`length`。\n"
  },
  "bifurcate": {
    "prefix": "30s_bifurcate",
    "body": [
      "const bifurcate = (arr, filter) =>",
      "  arr.reduce((acc, val, i) => (acc[filter[i] ? 0 : 1].push(val), acc), [[], []]); // 巧妙的用reduce初始化分组[[], []]，然后在累加过程中把每个元素放到相应分组，精简了代码"
    ],
    "description": "Splits values into two groups. If an element in `filter` is truthy, the corresponding element in the collection belongs to the first group; otherwise, it belongs to the second group.\n\n把一组值分为两组。如果一个元素在`filter`中为真（对应位置的布尔值为真，filter为一个布尔值列表），它被归到第一组；否则，它被归到第二组。\n\nUse `Array.prototype.reduce()` and `Array.prototype.push()` to add elements to groups, based on `filter`.\n\n使用`Array.prototype.reduce()` 和 `Array.prototype.push()`来对所有元素作用`filter`，并且基于其返回值分组。\n"
  },
  "bifurcateBy": {
    "prefix": "30s_bifurcateBy",
    "body": [
      "const bifurcateBy = (arr, fn) =>",
      "  arr.reduce((acc, val, i) => (acc[fn(val, i) ? 0 : 1].push(val), acc), [[], []]);"
    ],
    "description": "Splits values into two groups according to a predicate function, which specifies which group an element in the input collection belongs to. If the predicate function returns a truthy value, the collection element belongs to the first group; otherwise, it belongs to the second group.\n\n根据给定的断言函数`fn`（决定一个元素属于哪个分组的函数）把一组值分成两组。如果这个断言函数返回真值，这个元素被归到第一组；否则，它被归到第二组。\n\nUse `Array.prototype.reduce()` and `Array.prototype.push()` to add elements to groups, based on the value returned by `fn` for each element.\n\n使用`Array.prototype.reduce()` 和 `Array.prototype.push()`来对所有元素作用`fn`，并且基于其返回值分组。`fn`有两个参数`val`, `i`。\n"
  },
  "bind": {
    "prefix": "30s_bind",
    "body": [
      "const bind = (fn, context, ...boundArgs) => (...args) => fn.apply(context, [...boundArgs, ...args]);"
    ],
    "description": "Creates a function that invokes `fn` with a given context, optionally adding any additional supplied parameters to the beginning of the arguments.\n\n创建一个在指定上下文执行`fn`的函数，可选的在参数列表的头部添加额外提供的参数。\n\nReturn a `function` that uses `Function.prototype.apply()` to apply the given `context` to `fn`.\nUse `Array.prototype.concat()` to prepend any additional supplied parameters to the arguments.\n\n返回一个的函数`function`，它使用`Function.prototype.apply()`来把给定的`context`应用到`fn`。使用`Array.prototype.concat()`来把给定的额外参数添加到参数列表的头部。\n"
  },
  "bindAll": {
    "prefix": "30s_bindAll",
    "body": [
      "const bindAll = (obj, ...fns) =>",
      "  fns.forEach(",
      "    fn => (",
      "      (f = obj[fn]),",
      "      (obj[fn] = function() {",
      "        return f.apply(obj);",
      "      })",
      "    )",
      "  );"
    ],
    "description": "Binds methods of an object to the object itself, overwriting the existing method.\n\n把对象的方法绑定到对象本身上（方法的执行上下文都设置为对象本身），覆盖已经存在的方法。（为了解决一些指定的上下文不合适的情况，例如Dom中事件的监听回调中）\n\nUse `Array.prototype.forEach()` to return a `function` that uses `Function.prototype.apply()` to apply the given context (`obj`) to `fn` for each function specified.\n\n使用`Array.prototype.forEach()`返回一个函数，它使用`Function.prototype.apply()`来把指定的上下文(`obj`)应用到每个给出的`fn`函数上。\n"
  },
  "bindKey": {
    "prefix": "30s_bindKey",
    "body": [
      "const bindKey = (context, fn, ...boundArgs) => (...args) =>",
      "  context[fn].apply(context, [...boundArgs, ...args]);"
    ],
    "description": "Creates a function that invokes the method at a given key of an object, optionally adding any additional supplied parameters to the beginning of the arguments.\n\n创建一个执行给定对象的指定key中的方法的函数（调用对象的某个方法属性），可选的在参数列表的头部添加任何额外提供的参数。\n\nReturn a `function` that uses `Function.prototype.apply()` to bind `context[fn]` to `context`.\nUse the spread operator (`...`) to prepend any additional supplied parameters to the arguments.\n\n返回一个函数`function`，它使用`Function.prototype.apply()`来把`context[fn]`的上下文绑定为`context`。使用展开操作符(`...`)来把给定的额外参数添加到参数列表的头部。\n"
  },
  "binomialCoefficient": {
    "prefix": "30s_binomialCoefficient",
    "body": [
      "const binomialCoefficient = (n, k) => {",
      "  if (Number.isNaN(n) || Number.isNaN(k)) return NaN;",
      "  if (k < 0 || k > n) return 0;",
      "  if (k === 0 || k === n) return 1;",
      "  if (k === 1 || k === n - 1) return n;",
      "  if (n - k < k) k = n - k;",
      "  let res = n;",
      "  for (let j = 2; j <= k; j++) res *= (n - j + 1) / j; // 这一步也是计算组合数的代码片段",
      "  return Math.round(res);",
      "};"
    ],
    "description": "Evaluates the binomial coefficient of two integers `n` and `k`.\n\n计算两个整数`n`和`k`产生的二项式系数。\n\nUse `Number.isNaN()` to check if any of the two values is `NaN`.\nCheck if `k` is less than `0`, greater than or equal to `n`, equal to `1` or `n - 1` and return the appropriate result.\nCheck if `n - k` is less than `k` and switch their values accordingly.\nLoop from `2` through `k` and calculate the binomial coefficient.\nUse `Math.round()` to account for rounding errors in the calculation.\n\n使用`Number.isNaN()`检查两个值是否是`NaN`。检查`k`是否小于`0`、大于或等于`n`、等于`1`或者`n-1`并返回这些情况下合适的结果。检查`n - k`是否小于`k`并交换它们的值。循环`2`到`k`并计算相应的二项式系数。使用`Math.round()`来处理计算中的近似错误（由于有除法计算，可能产生浮点数结果）。\n"
  },
  "bottomVisible": {
    "prefix": "30s_bottomVisible",
    "body": [
      "const bottomVisible = () =>",
      "  document.documentElement.clientHeight + window.scrollY >=",
      "  (document.documentElement.scrollHeight || document.documentElement.clientHeight); // 是否已经向下滚动了足够的距离window.scrollY，使的页面最下面（在document.documentElement.scrollHeight位置）的已经被显示到视窗高度内了（document.documentElement.clientHeight）；另一种情况是页面不不需要滚动，已经完全显示了"
    ],
    "description": "Returns `true` if the bottom of the page is visible, `false` otherwise.\n\n如果当前页面的底部可见（已经显示在视窗中）则返回`true`，否则返回`false`\n\nUse `scrollY`, `scrollHeight` and `clientHeight` to determine if the bottom of the page is visible.\n\n使用`scrollY`, `scrollHeight` 和 `clientHeight`来判断当前页面的底部是否可见。\n"
  },
  "btoa": {
    "prefix": "30s_btoa",
    "body": [
      "const btoa = str => Buffer.from(str, 'binary').toString('base64');"
    ],
    "description": "Creates a base-64 encoded ASCII string from a String object in which each character in the string is treated as a byte of binary data.\n\n从字符串对象中创建一个base-64编码ASCII字符串，其中字符串中每个字符都被当做一个比特的二进制数据。\n\nCreate a `Buffer` for the given string with binary encoding and use `Buffer.toString('base64')` to return the encoded string.\n\n为给定的字符串创建一个二进制编码的`Buffer`，然后使用`Buffer.toString('base64')`来返回编码后的字符串。\n"
  },
  "byteSize": {
    "prefix": "30s_byteSize",
    "body": [
      "const byteSize = str => new Blob([str]).size;"
    ],
    "description": "Returns the length of a string in bytes.\n\n返回字节维度的字符串的长度。\n\nConvert a given string to a [`Blob` Object](https://developer.mozilla.org/en-US/docs/Web/API/Blob) and find its `size`.\n\n把字符串转换为一个[`Blob` Object](https://developer.mozilla.org/en-US/docs/Web/API/Blob)，并找出它的`size`。\n"
  },
  "call": {
    "prefix": "30s_call",
    "body": [
      "const call = (key, ...args) => context => context[key](...args);"
    ],
    "description": "Given a key and a set of arguments, call them when given a context. Primarily useful in composition.\n\n用给的一个`key`值和一组参数，在提供的`context`下调用函数（context理解为一个对象，key值理解为对象下的方法名），主要在组合模式中使用。（这个操作使JS中的对象方法不依赖于对象存在，使得动态类的构造成为可能）。\n\nUse a closure to call a stored key with stored arguments.\n\n用闭包把`key`名称和传入的参数存储，在更换`context`可以方便的调用。\n"
  },
  "capitalize": {
    "prefix": "30s_capitalize",
    "body": [
      "const capitalize = (",
      "  [first, ...rest],",
      "  lowerRest = false // [first, ...rest]解构的巧妙应用，不光是对象和数组才能解构",
      ") => first.toUpperCase() + (lowerRest ? rest.join('').toLowerCase() : rest.join(''));"
    ],
    "description": "Capitalizes the first letter of a string.\n\n大写字符串的第一个字母。\n\nUse array destructuring and `String.prototype.toUpperCase()` to capitalize first letter, `...rest` to get array of characters after first letter and then `Array.prototype.join('')` to make it a string again.\nOmit the `lowerRest` parameter to keep the rest of the string intact, or set it to `true` to convert to lowercase.\n\n使用数组解构和`String.prototype.toUpperCase()`来大写化第一个字母，使用`...rest`来获取第一个字母后的字符数组，然后用`Array.prototype.join('')`把它们重新连结为字符串。如果不传`lowerRest`参数，则原封不动的保留字符串剩余的字符，如果设置`lowerRest`为`true`则把剩余的字符转换为小写。\n"
  },
  "capitalizeEveryWord": {
    "prefix": "30s_capitalizeEveryWord",
    "body": [
      "const capitalizeEveryWord = str => str.replace(/\\b[a-z]/g, char => char.toUpperCase());"
    ],
    "description": "Capitalizes the first letter of every word in a string.\n\n大写化字符串中每一个词的第一个字母。\n\nUse `String.prototype.replace()` to match the first character of each word and `String.prototype.toUpperCase()` to capitalize it.\n\n使用`String.prototype.replace()`来匹配每个词的第一个字符，并使用`String.prototype.toUpperCase()`来把它大写化。\n"
  },
  "castArray": {
    "prefix": "30s_castArray",
    "body": [
      "const castArray = val => (Array.isArray(val) ? val : [val]);"
    ],
    "description": "Casts the provided value as an array if it's not one.\n\n如果给出的值不是一个数组，则把它放到一个数组中。（统一化的返回一个数组）\n\nUse `Array.prototype.isArray()` to determine if `val` is an array and return it as-is or encapsulated in an array accordingly.\n\n使用`Array.prototype.isArray()`来判定`val`是否是一个数组，并根据情况返回它本身或者包裹在一个数组中后的结果。\n"
  },
  "chainAsync": {
    "prefix": "30s_chainAsync",
    "body": [
      "const chainAsync = fns => {",
      "  let curr = 0;",
      "  const last = fns[fns.length - 1];",
      "  const next = () => {",
      "    const fn = fns[curr++];",
      "    fn === last ? fn() : fn(next);",
      "  };",
      "  next();",
      "};"
    ],
    "description": "Chains asynchronous functions.\n\n链式执行异步函数。\n\nLoop through an array of functions containing asynchronous events, calling `next` when each asynchronous event has completed.\n\n遍历执行一个包含异步事件的函数数组，当每个异步事件被完成时调用`next`。（创建了一个使用next来触发下一步的链式执行机制）\n"
  },
  "checkProp": {
    "prefix": "30s_checkProp",
    "body": [
      "const checkProp = (predicate, prop) => obj => !!predicate(obj[prop]);"
    ],
    "description": "Given a `predicate` function and a `prop` string, this curried function will then take an `object` to inspect by calling the property and passing it to the predicate.\n\nSummon `prop` on `obj`, pass it to a provided `predicate` function and return a masked boolean.\n"
  },
  "chunk": {
    "prefix": "30s_chunk",
    "body": [
      "const chunk = (arr, size) =>",
      "  Array.from(",
      "    { length: Math.ceil(arr.length / size) },",
      "    (v, i) => arr.slice(i * size, i * size + size) // slice会处理长度不足的情况，JS不存在越界错误",
      "  );"
    ],
    "description": "Chunks an array into smaller arrays of a specified size.\n\n把一个数组分成指定`size`的多个块。\n\nUse `Array.from()` to create a new array, that fits the number of chunks that will be produced.\nUse `Array.prototype.slice()` to map each element of the new array to a chunk the length of `size`.\nIf the original array can't be split evenly, the final chunk will contain the remaining elements.\n\n使用`Array.from()`来创建一个合适分块数量的新数组（长度为分块的数目）。使用`Array.prototype.slice()`来为新数组的每个元素生成一个长度为`size`的chunk。如果源数组不能不平均分块，最后一个chunk只包含剩下的元素（长度不是`size`）。\n"
  },
  "clampNumber": {
    "prefix": "30s_clampNumber",
    "body": [
      "const clampNumber = (num, a, b) => Math.max(Math.min(num, Math.max(a, b)), Math.min(a, b)); // 画个数轴可以想明白这个代码的逻辑，通过min/max的组合使用把代码精简到一行，且没有分支"
    ],
    "description": "Clamps `num` within the inclusive range specified by the boundary values `a` and `b`.\n\n把`num`限制在通过边界值`a`和`b`指定的包含区间内。\n\nIf `num` falls within the range, return `num`.\nOtherwise, return the nearest number in the range.\n\n如果`num`落在区间内，则返回`num`。否则，返回区间内最接近它的数。\n"
  },
  "cloneRegExp": {
    "prefix": "30s_cloneRegExp",
    "body": [
      "const cloneRegExp = regExp => new RegExp(regExp.source, regExp.flags);"
    ],
    "description": "Clones a regular expression.\n\n复制一个正则表达式。\n\nUse `new RegExp()`, `RegExp.source` and `RegExp.flags` to clone the given regular expression.\n\n使用`new RegExp()`, `RegExp.source`和`RegExp.flags`来复制给出的正则表达式。\n"
  },
  "coalesce": {
    "prefix": "30s_coalesce",
    "body": [
      "const coalesce = (...args) => args.find(_ => ![undefined, null].includes(_));"
    ],
    "description": "Returns the first non-null/undefined argument.\n\n返回第一个不是null/undefined的参数。\n\nUse `Array.prototype.find()` to return the first non `null`/`undefined` argument.\n\n使用`Array.prototype.find()`来返回第一个非`null`/`undefined`参数。\n"
  },
  "coalesceFactory": {
    "prefix": "30s_coalesceFactory",
    "body": [
      "const coalesceFactory = valid => (...args) => args.find(valid); // 建立了一个找到第一符合条件元素的通用方法"
    ],
    "description": "Returns a customized coalesce function that returns the first argument that returns `true` from the provided argument validation function.\n\n返回一个自定义联合函数，它从返回参数中第一个被验证函数`valid`返回`true`的参数。\n\nUse `Array.prototype.find()` to return the first argument that returns `true` from the provided argument validation function.\n\n使用`Array.prototype.find()`来从给出的验证函数参数中返回第一个返回`true`的参数。\n"
  },
  "collectInto": {
    "prefix": "30s_collectInto",
    "body": [
      "const collectInto = fn => (...args) => fn(args);"
    ],
    "description": "Changes a function that accepts an array into a variadic function.\n\n把一个接受数组参数的函数改造成接受可变数目参数的函数。\n\nGiven a function, return a closure that collects all inputs into an array-accepting function.\n\n传入一个接受数组参数的函数，返回一个把所有参数收集到一个array后传给这个函数调用的闭包。\n"
  },
  "colorize": {
    "prefix": "30s_colorize",
    "body": [
      "const colorize = (...args) => ({",
      "  black: `\\x1b[30m${args.join(' ')}`,",
      "  red: `\\x1b[31m${args.join(' ')}`,",
      "  green: `\\x1b[32m${args.join(' ')}`,",
      "  yellow: `\\x1b[33m${args.join(' ')}`,",
      "  blue: `\\x1b[34m${args.join(' ')}`,",
      "  magenta: `\\x1b[35m${args.join(' ')}`,",
      "  cyan: `\\x1b[36m${args.join(' ')}`,",
      "  white: `\\x1b[37m${args.join(' ')}`,",
      "  bgBlack: `\\x1b[40m${args.join(' ')}\\x1b[0m`,",
      "  bgRed: `\\x1b[41m${args.join(' ')}\\x1b[0m`,",
      "  bgGreen: `\\x1b[42m${args.join(' ')}\\x1b[0m`,",
      "  bgYellow: `\\x1b[43m${args.join(' ')}\\x1b[0m`,",
      "  bgBlue: `\\x1b[44m${args.join(' ')}\\x1b[0m`,",
      "  bgMagenta: `\\x1b[45m${args.join(' ')}\\x1b[0m`,",
      "  bgCyan: `\\x1b[46m${args.join(' ')}\\x1b[0m`,",
      "  bgWhite: `\\x1b[47m${args.join(' ')}\\x1b[0m`",
      "});"
    ],
    "description": "Add special characters to text to print in color in the console (combined with `console.log()`).\n\n把特定的字符串添加到console中打印的文字，以使它们被打印为彩色（配合`console.log()`）。\n\nUse template literals and special characters to add the appropriate color code to the string output.\nFor background colors, add a special character that resets the background color at the end of the string.\n\n使用模板字面量和特定的字符来给字符串输出添加合适的颜色码。对于背景颜色，在字符串的结尾添加重置背景颜色的特定字符。\n"
  },
  "compact": {
    "prefix": "30s_compact",
    "body": [
      "const compact = arr => arr.filter(Boolean); // 因为filter参数为必传，这里用Boolean作为过滤函数传入，即省事又合理"
    ],
    "description": "Removes falsy values from an array.\n\n把数组中所有假值移除掉。\n\nUse `Array.prototype.filter()` to filter out falsy values (`false`, `null`, `0`, `\"\"`, `undefined`, and `NaN`).\n\n使用`Array.prototype.filter()`来过滤掉假值(`false`, `null`, `0`, `\"\"`, `undefined`, and `NaN`)。\n"
  },
  "compactWhitespace": {
    "prefix": "30s_compactWhitespace",
    "body": [
      "const compactWhitespace = str => str.replace(/\\s{2,}/g, ' ');"
    ],
    "description": "Returns a string with whitespaces compacted.\n\n返回一个压缩了空白字符的字符串。\n\nUse `String.prototype.replace()` with a regular expression to replace all occurrences of 2 or more whitespace characters with a single space.\n\n使用`String.prototype.replace()`和一个正则表达式来把出现了2个或更多次（连续）的空白字符替换为单个空格。\n"
  },
  "compose": {
    "prefix": "30s_compose",
    "body": [
      "const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));"
    ],
    "description": "Performs right-to-left function composition.\n\n执行从右到左的函数复合（嵌套的函数调用）。\n\nUse `Array.prototype.reduce()` to perform right-to-left function composition.\nThe last (rightmost) function can accept one or more arguments; the remaining functions must be unary.\n\n使用`Array.prototype.reduce()`来执行从右到左的函数复合。最后（最右边）的函数可以接收一个或多个参数；剩余的函数必须是一元的。\n"
  },
  "composeRight": {
    "prefix": "30s_composeRight",
    "body": [
      "const composeRight = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));"
    ],
    "description": "Performs left-to-right function composition.\n\n执行从左到右的函数复合（嵌套的函数调用）。\n\nUse `Array.prototype.reduce()` to perform left-to-right function composition.\nThe first (leftmost) function can accept one or more arguments; the remaining functions must be unary.\n\n使用`Array.prototype.reduce()`来执行从左到右的函数组合。第一个（最左边）的函数可以接收一个或多个参数；剩余的函数必须是一元的。\n"
  },
  "converge": {
    "prefix": "30s_converge",
    "body": [
      "const converge = (converger, fns) => (...args) => converger(...fns.map(fn => fn.apply(null, args)));",
      "// 返回结果是一个函数，这个函数接受的参数传给分支函数，每个分支函数处理后把结果列表作为聚合函数的参数。"
    ],
    "description": "Accepts a converging function and a list of branching functions and returns a function that applies each branching function to the arguments and the results of the branching functions are passed as arguments to the converging function.\n\n接受一个聚合函数和一个分支函数列表并返回一个把每个分支函数应用到参数列表的函数，分支函数列表的结果列表被作为参数传给聚合函数。\n\nUse `Array.prototype.map()` and `Function.prototype.apply()` to apply each function to the given arguments.\nUse the spread operator (`...`) to call `coverger` with the results of all other functions.\n\n使用`Array.prototype.map()`和`Function.prototype.apply()`来对给定的参数执行每个函数。使用展开操作符(`...`)来对其他函数的结果列表调用`coverger`。\n"
  },
  "copyToClipboard": {
    "prefix": "30s_copyToClipboard",
    "body": [
      "const copyToClipboard = str => {",
      "  const el = document.createElement('textarea');",
      "  el.value = str;",
      "  el.setAttribute('readonly', '');",
      "  el.style.position = 'absolute';",
      "  el.style.left = '-9999px';",
      "  document.body.appendChild(el);",
      "  const selected =",
      "    document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : false;",
      "  el.select(); // 选中创建的textarea",
      "  document.execCommand('copy'); // 执行copy",
      "  document.body.removeChild(el);",
      "  if (selected) {",
      "    document.getSelection().removeAllRanges();",
      "    document.getSelection().addRange(selected);",
      "  }",
      "};"
    ],
    "description": "Copy a string to the clipboard. \nOnly works as a result of user action (i.e. inside a `click` event listener).\n\n把一个字符串拷贝到剪切板。只有在用户操作时才生效（i.e. 在一个`click`事件的监听函数中）。\n\n⚠️ **NOTICE:** The same functionality can be easily implemented by using the new asynchronous Clipboard API, which is still experimental but should be used in the future instead of this snippet. Find out more about it [here](https://github.com/w3c/clipboard-apis/blob/master/explainer.adoc#writing-to-the-clipboard).\n\n⚠️ **NOTICE:** 相同的功能可以很容易的用还在实验阶段但未来可能替代本代码片段的新异步剪切板API实现。更多信息参见[here](https://github.com/w3c/clipboard-apis/blob/master/explainer.adoc#writing-to-the-clipboard).\n\nCreate a new `<textarea>` element, fill it with the supplied data and add it to the HTML document.\nUse `Selection.getRangeAt()`to store the selected range (if any).\nUse `document.execCommand('copy')` to copy to the clipboard.\nRemove the `<textarea>` element from the HTML document.\nFinally, use `Selection().addRange()` to recover the original selected range (if any).\n\n创建一个`<textarea>`元素，用提供的数据填充它，并把它添加到HTML的文档流中。使用 `Selection.getRangeAt()`来存储选中的区域（如果有的话）。使用`document.execCommand('copy')`来把内容拷贝到剪切板。把`<textarea>`从HTML的文档流中删除。最后，使用`Selection().addRange()`来恢复原始选择的区域（如果有）。\n"
  },
  "countBy": {
    "prefix": "30s_countBy",
    "body": [
      "const countBy = (arr, fn) =>",
      "  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => {",
      "    acc[val] = (acc[val] || 0) + 1;",
      "    return acc;",
      "  }, {});"
    ],
    "description": "Groups the elements of an array based on the given function and returns the count of elements in each group.\n\n根据给定的函数对数组中元素分组，返回每组中元素的个数。\n\nUse `Array.prototype.map()` to map the values of an array to a function or property name.\nUse `Array.prototype.reduce()` to create an object, where the keys are produced from the mapped results.\n\n使用`Array.prototype.map()`对数组中每个元素调用`fn`或取出`fn`的属性值（支持两种用法）。使用`Array.prototype.reduce()`来建立一个属性键值来自map结果的计数对象。\n"
  },
  "counter": {
    "prefix": "30s_counter",
    "body": [
      "const counter = (selector, start, end, step = 1, duration = 2000) => {",
      "  let current = start,",
      "    _step = (end - start) * step < 0 ? -step : step,",
      "    timer = setInterval(() => {",
      "      current += _step;",
      "      document.querySelector(selector).innerHTML = current;",
      "      if (current >= end) document.querySelector(selector).innerHTML = end;",
      "      if (current >= end) clearInterval(timer);",
      "    }, Math.abs(Math.floor(duration / (end - start))));",
      "  return timer;",
      "};"
    ],
    "description": "Creates a counter with the specified range, step and duration for the specified selector.\n\n用指定的范围、步幅、过程时长为指定的选择器（DOM）创建一个的计数器。\n\nCheck if `step` has the proper sign and change it accordingly.\nUse `setInterval()` in combination with `Math.abs()` and `Math.floor()` to calculate the time between each new text draw.\nUse `document.querySelector().innerHTML` to update the value of the selected element.\nOmit the fourth parameter, `step`, to use a default step of `1`.\nOmit the fifth parameter, `duration`, to use a default duration of `2000`ms.\n\n检查`step`是否有合适的正负值，并修改成合适的正负值。使用`setInterval()`结合`Math.abs()` 和 `Math.floor()`来控制每次新文字渲染的间隔。使用`document.querySelector().innerHTML`来更新选中元素的值。如果第四个参数`step`不传，使用`1`作为默认步幅值；如果第五个参数`duration`不传，使用`2000`ms作为默认的过程时长。\n"
  },
  "countOccurrences": {
    "prefix": "30s_countOccurrences",
    "body": [
      "const countOccurrences = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);"
    ],
    "description": "Counts the occurrences of a value in an array.\n\n计算一个数组中某个`val`出现的次数。\n\nUse `Array.prototype.reduce()` to increment a counter each time you encounter the specific value inside the array.\n\n使用`Array.prototype.reduce()`来遍历数组，每次指定的值出现时增加计数。\n"
  },
  "createDirIfNotExists": {
    "prefix": "30s_createDirIfNotExists",
    "body": [
      "const fs = require('fs');",
      "const createDirIfNotExists = dir => (!fs.existsSync(dir) ? fs.mkdirSync(dir) : undefined);"
    ],
    "description": "Creates a directory, if it does not exist.\n\n如果文件夹不存在则创建一个。\n\nUse `fs.existsSync()` to check if the directory exists, `fs.mkdirSync()` to create it.\n\n使用`fs.existsSync()`来检查文件夹是否存在，使用`fs.mkdirSync()` 来创建它。\n"
  },
  "createElement": {
    "prefix": "30s_createElement",
    "body": [
      "const createElement = str => {",
      "  const el = document.createElement('div');",
      "  el.innerHTML = str;",
      "  return el.firstElementChild;",
      "};"
    ],
    "description": "Creates an element from a string (without appending it to the document). \nIf the given string contains multiple elements, only the first one will be returned.\n\n从字符串中创建一个元素（不把它追加到文档流中）。如果给定的字符串包含多个元素，只有一个会被返回。\n\nUse `document.createElement()` to create a new element.\nSet its `innerHTML` to the string supplied as the argument. \nUse `ParentNode.firstElementChild` to return the element version of the string.\n\n使用`document.createElement()`来创建一个新元素。把它的`innerHTML`设置成参数提供的字符串。使用`ParentNode.firstElementChild`返回字符串的Html元素形式。\n"
  },
  "createEventHub": {
    "prefix": "30s_createEventHub",
    "body": [
      "const createEventHub = () => ({",
      "  hub: Object.create(null),",
      "  emit(event, data) {",
      "    (this.hub[event] || []).forEach(handler => handler(data));",
      "  },",
      "  on(event, handler) {",
      "    if (!this.hub[event]) this.hub[event] = [];",
      "    this.hub[event].push(handler);",
      "  },",
      "  off(event, handler) {",
      "    const i = (this.hub[event] || []).findIndex(h => h === handler);",
      "    if (i > -1) this.hub[event].splice(i, 1);",
      "    if (this.hub[event].length === 0) delete this.hub[event];",
      "  }",
      "});"
    ],
    "description": "Creates a pub/sub ([publish–subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)) event hub with `emit`, `on`, and `off` methods.\n\n用`emit`、`on`和`off`方法创建一个pub/sub ([publish–subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern))（发布/订阅）模式的事件分发器。\n\nUse `Object.create(null)` to create an empty `hub` object that does not inherit properties from `Object.prototype`.\nFor `emit`, resolve the array of handlers based on the `event` argument and then run each one with `Array.prototype.forEach()` by passing in the data as an argument.\nFor `on`, create an array for the event if it does not yet exist, then use `Array.prototype.push()` to add the handler\nto the array.\nFor `off`, use `Array.prototype.findIndex()` to find the index of the handler in the event array and remove it using `Array.prototype.splice()`.\n\n使用`Object.create(null)`来创建一个不包含从`Object.prototype`继承来的属性的空`hub`对象。`emit`功能：基于`event`参数解析handler数组，然后把数据作为一个参数传入，使用`Array.prototype.forEach()`调用每一个handler。`on`功能：创建一个还不存在的事件数组，然后用`Array.prototype.push()`把handler添加到数组中。`off`功能：使用`Array.prototype.findIndex()`在事件数组中找到handler的序号，并用`Array.prototype.splice()`把它删除。\n"
  },
  "CSVToArray": {
    "prefix": "30s_CSVToArray",
    "body": [
      "const CSVToArray = (data, delimiter = ',', omitFirstRow = false) =>",
      "  data",
      "    .slice(omitFirstRow ? data.indexOf('\\n') + 1 : 0)",
      "    .split('\\n')",
      "    .map(v => v.split(delimiter));"
    ],
    "description": "Converts a comma-separated values (CSV) string to a 2D array.\n\n把一个逗号分隔值（CSV）字符串转为二维数组。\n\nUse `Array.prototype.slice()` and `Array.prototype.indexOf('\\n')` to remove the first row (title row) if `omitFirstRow` is `true`.\nUse `String.prototype.split('\\n')` to create a string for each row, then `String.prototype.split(delimiter)` to separate the values in each row.\nOmit the second argument, `delimiter`, to use a default delimiter of `,`.\nOmit the third argument, `omitFirstRow`, to include the first row (title row) of the CSV string.\n\n如果`omitFirstRow`是`true`，则使用`Array.prototype.slice()`和`Array.prototype.indexOf('\\n')`删除第一行(标题行)。使用`String.prototype.split('\\n')`来为每一行创建一个字符串，然后用`String.prototype.split(delimiter)`来拆分每一行的值。如果不传第二个参数`delimiter`，默认值为`,`。如果不传第三个参数`omitFirstRow`，默认包含CSV字符串的第一行（标题行）。\n"
  },
  "CSVToJSON": {
    "prefix": "30s_CSVToJSON",
    "body": [
      "const CSVToJSON = (data, delimiter = ',') => {",
      "  const titles = data.slice(0, data.indexOf('\\n')).split(delimiter);",
      "  return data",
      "    .slice(data.indexOf('\\n') + 1)",
      "    .split('\\n')",
      "    .map(v => {",
      "      const values = v.split(delimiter);",
      "      return titles.reduce((obj, title, index) => ((obj[title] = values[index]), obj), {});",
      "    });",
      "};"
    ],
    "description": "Converts a comma-separated values (CSV) string to a 2D array of objects.\nThe first row of the string is used as the title row.\n\n将一个逗号分隔值（CSV）字符串转为对象的二维数组。字符串的第一行用作标题行。\n\nUse `Array.prototype.slice()` and `Array.prototype.indexOf('\\n')` and `String.prototype.split(delimiter)` to separate the first row (title row) into values.\nUse `String.prototype.split('\\n')` to create a string for each row, then `Array.prototype.map()` and `String.prototype.split(delimiter)` to separate the values in each row.\nUse `Array.prototype.reduce()` to create an object for each row's values, with the keys parsed from the title row.\nOmit the second argument, `delimiter`, to use a default delimiter of `,`.\n\n使用`Array.prototype.slice()`和`Array.prototype.indexOf('\\n')`还有`String.prototype.split(delimiter)`来把第一行（标题行）转为值列表。使用`String.prototype.split('\\n')`来为每一行创建一个字符串，然后用`Array.prototype.map()`和`String.prototype.split(delimiter)`来拆分每一行的值。使用`Array.prototype.reduce()` 来为每一行的值创建一个对象，它的键解析自CSV字符串的标题行。如果不传第二个参数`delimiter`，默认值为`,`。\n"
  },
  "currentURL": {
    "prefix": "30s_currentURL",
    "body": [
      "const currentURL = () => window.location.href;"
    ],
    "description": "Returns the current URL.\n\n返回当前页的URL。\n\nUse `window.location.href` to get current URL.\n\n使用`window.location.href`来获取当前URL。\n"
  },
  "curry": {
    "prefix": "30s_curry",
    "body": [
      "const curry = (fn, arity = fn.length, ...args) =>",
      "  // fn.length可以取得fn的参数数目",
      "  arity <= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args); // 已经有的参数先绑上；bind一方面绑上下文this，一方面绑参数"
    ],
    "description": "Curries a function.\n\n柯里化一个函数。\n\nUse recursion.\nIf the number of provided arguments (`args`) is sufficient, call the passed function `fn`.\nOtherwise, return a curried function `fn` that expects the rest of the arguments.\nIf you want to curry a function that accepts a variable number of arguments (a variadic function, e.g. `Math.min()`), you can optionally pass the number of arguments to the second parameter `arity`.\n\n使用递归。如果给定参数列表(`args`)的个数是足够的，则使用它们调用传入的函数`fn`。否则返回一个接收剩余参数的柯里化的函数`fn`。如果你想柯里化一个接受可变数目参数的函数（可变参数函数, 例如`Math.min()`），你可以可选的传入参数列表的长度到第二个参数`arity`。\n"
  },
  "dayOfYear": {
    "prefix": "30s_dayOfYear",
    "body": [
      "const dayOfYear = date =>",
      "  Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);",
      "// 直接给参数一个默认值，计算当天"
    ],
    "description": "Gets the day of the year from a `Date` object.\n\n从一个`Date`对象中获取它是一年中的第多少天。\n\nUse `new Date()` and `Date.prototype.getFullYear()` to get the first day of the year as a `Date` object, subtract it from the provided `date` and divide with the milliseconds in each day to get the result.\nUse `Math.floor()` to appropriately round the resulting day count to an integer.\n\n使用`new Date()`和`Date.prototype.getFullYear()`获取这一年的第一天来作为一个`Date`对象，用给定的`date`减掉它并除以每天中的毫秒数来获得结果。使用`Math.floor()`把计算结果天数适当的取整。\n"
  },
  "debounce": {
    "prefix": "30s_debounce",
    "body": [
      "const debounce = (fn, ms = 0) => {",
      "  let timeoutId;",
      "  return function(...args) {",
      "    clearTimeout(timeoutId);",
      "    timeoutId = setTimeout(() => fn.apply(this, args), ms);",
      "  };",
      "};"
    ],
    "description": "Creates a debounced function that delays invoking the provided function until at least `ms` milliseconds have elapsed since the last time it was invoked.\n\n创建一个最少延迟`ms`毫秒执行（本次在上一次执行`ms`毫秒之后）给定函数的防抖的函数。通俗的讲：停止改变大小n毫秒后才执行函数。\n\nEach time the debounced function is invoked, clear the current pending timeout with `clearTimeout()` and use `setTimeout()` to create a new timeout that delays invoking the function until at least `ms` milliseconds has elapsed. Use `Function.prototype.apply()` to apply the `this` context to the function and provide the necessary arguments.\nOmit the second argument, `ms`, to set the timeout at a default of 0 ms.\n\n每次防抖的函数被执行，都用`clearTimeout()`把当前挂起的timeout清除，并用`setTimeout()`创建一个新的最少延迟`ms`毫秒执行这个函数的timeout。使用`Function.prototype.apply()`来把`this`上下文环境应用到这个函数上并提供需要的参数列表。如果不传第二个参数`ms`，则timeout默认为0ms。"
  },
  "decapitalize": {
    "prefix": "30s_decapitalize",
    "body": [
      "const decapitalize = ([first, ...rest], upperRest = false) =>",
      "  first.toLowerCase() + (upperRest ? rest.join('').toUpperCase() : rest.join(''));"
    ],
    "description": "Decapitalizes the first letter of a string.\n\n去大写化一个字符串的首字母。\n\nUse array destructuring and `String.toLowerCase()` to decapitalize first letter, `...rest` to get array of characters after first letter and then `Array.prototype.join('')` to make it a string again.\nOmit the `upperRest` parameter to keep the rest of the string intact, or set it to `true` to convert to uppercase.\n\n使用数组解构和`String.toLowerCase()`来去大写化首字母，使用`...rest`来获取首字母后的字符数组，然后用`Array.prototype.join('')`把它们重新变为字符串。如果不传`upperRest`参数则保持字符串剩余部分不变；把它设置成`true`，代表将剩余部分转换为大写。\n"
  },
  "deepClone": {
    "prefix": "30s_deepClone",
    "body": [
      "const deepClone = obj => {",
      "  if (obj === null) return null;",
      "  let clone = Object.assign({}, obj);",
      "  Object.keys(clone).forEach(",
      "    key => (clone[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key])",
      "  );",
      "  return Array.isArray(obj) && obj.length",
      "    ? (clone.length = obj.length) && Array.from(clone)",
      "    : Array.isArray(obj)",
      "      ? Array.from(obj)",
      "      : clone;",
      "};"
    ],
    "description": "Creates a deep clone of an object.\n\n创建一个对象的深拷贝。\n\nUse recursion.\nCheck if the passed object is `null` and, if so, return `null`.\nUse `Object.assign()` and an empty object (`{}`) to create a shallow clone of the original.\nUse `Object.keys()` and `Array.prototype.forEach()` to determine which key-value pairs need to be deep cloned.\n\n使用递归。使用`Object.assign()`和一个空对象(`{}`)来创建一个原始对象的浅拷贝。使用`Object.keys()`和`Array.prototype.forEach()`来确定哪个键值对需要深拷贝。\n"
  },
  "deepFlatten": {
    "prefix": "30s_deepFlatten",
    "body": [
      "const deepFlatten = arr => [].concat(...arr.map(v => (Array.isArray(v) ? deepFlatten(v) : v)));"
    ],
    "description": "Deep flattens an array.\n\n深度扁平化一个数组。（把多维的数组元素放到一个一维数组中）\n\nUse recursion.\nUse `Array.prototype.concat()` with an empty array (`[]`) and the spread operator (`...`) to flatten an array.\nRecursively flatten each element that is an array.\n\n使用递归。使用一个空数组(`[]`)的`Array.prototype.concat()`和展开操作符(`...`)来扁平化数组。递归每个数组类型的元素。\n"
  },
  "deepFreeze": {
    "prefix": "30s_deepFreeze",
    "body": [
      "const deepFreeze = obj =>",
      "  Object.keys(obj).forEach(prop =>",
      "    !(obj[prop] instanceof Object) || Object.isFrozen(obj[prop]) ? null : deepFreeze(obj[prop])",
      "  ) || Object.freeze(obj);"
    ],
    "description": "Deep freezes an object.\n\n深层冻结一个对象。\n\nCalls `Object.freeze(obj)` recursively on all unfrozen properties of passed object that are `instanceof` object.\n\n递归的对传入的是对象（通过`instanceof`判断是否是对象）实例的所有没有冻结的属性调用`Object.freeze(obj)`。\n"
  },
  "deepGet": {
    "prefix": "30s_deepGet",
    "body": [
      "const deepGet = (obj, keys) => keys.reduce((xs, x) => (xs && xs[x] ? xs[x] : null), obj);"
    ],
    "description": "Returns the target value in a nested JSON object, based on the `keys` array.\n\nCompare the keys you want in the nested JSON object as an `Array`.\nUse `Array.prototype.reduce()` to get value from nested JSON object one by one. \nIf the key exists in object, return target value, otherwise, return `null`.\n"
  },
  "deepMapKeys": {
    "prefix": "30s_deepMapKeys",
    "body": [
      "const deepMapKeys = (obj, f) =>",
      "  Array.isArray(obj)",
      "    ? obj.map(val => deepMapKeys(val, f))",
      "    : typeof obj === 'object'",
      "      ? Object.keys(obj).reduce((acc, current) => {",
      "        const val = obj[current];",
      "        acc[f(current)] =",
      "          val !== null && typeof val === 'object' ? deepMapKeys(val, f) : (acc[f(current)] = val);",
      "        return acc;",
      "      }, {})",
      "      : obj;"
    ],
    "description": "Deep maps an object's keys.\n\n建立一个对象键列表的深度映射。（对对象中每个key都应用指定函数）\n\nCreates an object with the same values as the provided object and keys generated by running the provided function for each key.\n\n用和给出的对象相同的值和对每个键应用给出的函数后的新键，创建一个对象。\n\nUse `Object.keys(obj)` to iterate over the object's keys. \nUse `Array.prototype.reduce()` to create a new object with the same values and mapped keys using `fn`.\n\n使用`Object.keys(obj)`来遍历对象的键列表。使用`Array.prototype.reduce()`来用相同的值和用`fn`映射后的键来创建一个新对象。\n"
  },
  "defaults": {
    "prefix": "30s_defaults",
    "body": [
      "const defaults = (obj, ...defs) => Object.assign({}, obj, ...defs.reverse(), obj);"
    ],
    "description": "Assigns default values for all properties in an object that are `undefined`.\n\n把默认值赋给一个对象中所有`undefined`的属性。\n\nUse `Object.assign()` to create a new empty object and copy the original one to maintain key order, use `Array.prototype.reverse()` and the spread operator `...` to combine the default values from left to right, finally use `obj` again to overwrite properties that originally had a value.\n\n使用`Object.assign()`来创建一个新的空对象，然后拷贝一个原始对象维护键的顺序，使用`Array.prototype.reverse()`和展开从操作符`...`来把默认值从左到右整合到对象中，最后再次使用`obj`来覆盖（恢复）原来就有值的属性。\n"
  },
  "defer": {
    "prefix": "30s_defer",
    "body": [
      "const defer = (fn, ...args) => setTimeout(fn, 1, ...args);"
    ],
    "description": "Defers invoking a function until the current call stack has cleared.\n\n延迟直到当前的调用栈清空后才执行函数（原理涉及到JS任务队列机制）。\n\nUse `setTimeout()` with a timeout of 1ms to add a new event to the browser event queue and allow the rendering engine to complete its work. Use the spread (`...`) operator to supply the function with an arbitrary number of arguments.\n\n使用一个1ms的timeout的`setTimeout()`来向浏览器事件队列中添加一个新的事件，然后让渲染引擎继续它的工作。使用展开操作符(`...`)来给函数提供相应参数数目的参数列表。\n"
  },
  "degreesToRads": {
    "prefix": "30s_degreesToRads",
    "body": [
      "const degreesToRads = deg => (deg * Math.PI) / 180.0;"
    ],
    "description": "Converts an angle from degrees to radians.\n\n把一个角的角度值转为弧度值。\n\nUse `Math.PI` and the degree to radian formula to convert the angle from degrees to radians.\n\n使用`Math.PI`和角度到弧度的计算公式来把角的角度值转为弧度值。\n"
  },
  "delay": {
    "prefix": "30s_delay",
    "body": [
      "const delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args);"
    ],
    "description": "Invokes the provided function after `wait` milliseconds.\n\n`wait`毫秒后执行给定的函数。\n\nUse `setTimeout()` to delay execution of `fn`.\nUse the spread (`...`) operator to supply the function with an arbitrary number of arguments.\n\n使用`setTimeout()`来延迟执行`fn`。使用展开操作符(`...`)来给函数提供相应参数数目的参数列表。\n"
  },
  "detectDeviceType": {
    "prefix": "30s_detectDeviceType",
    "body": [
      "const detectDeviceType = () =>",
      "  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)",
      "    ? 'Mobile'",
      "    : 'Desktop';"
    ],
    "description": "Detects whether the website is being opened in a mobile device or a desktop/laptop.\n\n探测当前网站是在手机设备中还是桌面/笔记本设备中打开。\n\nUse a regular expression to test the `navigator.userAgent` property to figure out if the device is a mobile device or a desktop/laptop.\n\n使用一个正则表达式来测试`navigator.userAgent`，推测出当前设备是一个手机设备还是桌面/笔记本设备。\n"
  },
  "difference": {
    "prefix": "30s_difference",
    "body": [
      "const difference = (a, b) => {",
      "  const s = new Set(b);",
      "  return a.filter(x => !s.has(x));",
      "};"
    ],
    "description": "Returns the difference between two arrays.\n\n返回两个数组中不同的元素。\n\nCreate a `Set` from `b`, then use `Array.prototype.filter()` on `a` to only keep values not contained in `b`.\n\n从数组`b`创建一个`Set`，然后对数组`a`使用`Array.prototype.filter()`来过滤出不在`b`中的元素。\n"
  },
  "differenceBy": {
    "prefix": "30s_differenceBy",
    "body": [
      "const differenceBy = (a, b, fn) => {",
      "  const s = new Set(b.map(fn));",
      "  return a.map(fn).filter(el => !s.has(el));",
      "};"
    ],
    "description": "Returns the difference between two arrays, after applying the provided function to each array element of both.\n\n在对数组中元素都应用一个给定的函数的基础上，返回两个数组中不同的元素。\n\nCreate a `Set` by applying `fn` to each element in `b`, then use `Array.prototype.map()` to apply `fn` to each element in `a`, then `Array.prototype.filter()`\n\n用`fn`作用域数组`b`中每个元素的结果创建一个`Set`，然后使用`Array.prototype.map()`对数组`a`中的每个元素应用`fn`，然后使用`Array.prototype.filter()`（过滤出不在之前set中的元素）。\n"
  },
  "differenceWith": {
    "prefix": "30s_differenceWith",
    "body": [
      "const differenceWith = (arr, val, comp) => arr.filter(a => val.findIndex(b => comp(a, b)) === -1);"
    ],
    "description": "Filters out all values from an array for which the comparator function does not return `true`.\n\n过滤出所有被比较函数`comp`判断为不相等的元素。\n\nUse `Array.prototype.filter()` and `Array.prototype.findIndex()` to find the appropriate values.\n\n使用`Array.prototype.filter()` 和 `Array.prototype.findIndex()`来找到符合条件的值。\n"
  },
  "dig": {
    "prefix": "30s_dig",
    "body": [
      "const dig = (obj, target) =>",
      "  target in obj",
      "    ? obj[target]",
      "    : Object.values(obj).reduce((acc, val) => {",
      "      if (acc !== undefined) return acc;",
      "      if (typeof val === 'object') return dig(val, target);",
      "    }, undefined);"
    ],
    "description": "Returns the target value in a nested JSON object, based on the given key.\n\n根据给出的键，返回嵌套JSON对象中的目标值。\n\nUse the `in` operator to check if `target` exists in `obj`.\nIf found, return the value of `obj[target]`, otherwise use `Object.values(obj)` and `Array.prototype.reduce()` to recursively call `dig` on each nested object until the first matching key/value pair is found.\n\n使用`in`操作符来检查`obj`中是否存在`target`。如果找到了，返回`obj[target]`的值，否则使用`Object.values(obj)`和`Array.prototype.reduce()`来对嵌套对象递归调用`dig`直到第一个匹配的键值对被找到。\n"
  },
  "digitize": {
    "prefix": "30s_digitize",
    "body": [
      "const digitize = n => [...`${n}`].map(i => parseInt(i));"
    ],
    "description": "Converts a number to an array of digits.\n\n把一个数转换为每一位的数组。\n\nConvert the number to a string, using the spread operator (`...`) to build an array.\nUse `Array.prototype.map()` and `parseInt()` to transform each value to an integer.\n\n把这个数转为一个字符串，是一种展开操作符(`...`)来创建一个数组。使用`Array.prototype.map()`和`parseInt()`来把每个值转为整数。\n"
  },
  "distance": {
    "prefix": "30s_distance",
    "body": [
      "const distance = (x0, y0, x1, y1) => Math.hypot(x1 - x0, y1 - y0);"
    ],
    "description": "Returns the distance between two points.\n\n返回两个点之间的距离。\n\nUse `Math.hypot()` to calculate the Euclidean distance between two points.\n\n使用`Math.hypot()`来计算两个点之间的欧式距离。\n"
  },
  "drop": {
    "prefix": "30s_drop",
    "body": [
      "const drop = (arr, n = 1) => arr.slice(n);"
    ],
    "description": "Returns a new array with `n` elements removed from the left.\n\n返回一个删除前`n`个元素后的数组。\n\nUse `Array.prototype.slice()` to remove the specified number of elements from the left.\n\n使用`Array.prototype.slice()`来把指定数量的元素从数组左端删掉（返回剩余数组）。\n"
  },
  "dropRight": {
    "prefix": "30s_dropRight",
    "body": [
      "const dropRight = (arr, n = 1) => arr.slice(0, -n);"
    ],
    "description": "Returns a new array with `n` elements removed from the right.\n\n返回一个删除右边`n`个元素后的数组。\n\nUse `Array.prototype.slice()` to remove the specified number of elements from the right.\n\n使用`Array.prototype.slice()`来把指定数量的元素从数组右端删掉（返回剩余数组）\n"
  },
  "dropRightWhile": {
    "prefix": "30s_dropRightWhile",
    "body": [
      "const dropRightWhile = (arr, func) => {",
      "  let rightIndex = arr.length;",
      "  while (rightIndex-- && !func(arr[rightIndex]));",
      "  return arr.slice(0, rightIndex + 1); // 返回一个新的数组",
      "};"
    ],
    "description": "Removes elements from the end of an array until the passed function returns `true`. Returns the remaining elements in the array.\n\n从数组尾部开始删掉给出的函数作用后返回`false`的元素，直到遇到第一个返回`true`的。返回数组的剩余元素。\n\nLoop through the array, using `Array.prototype.slice()` to drop the last element of the array until the returned value from the function is `true`.\nReturns the remaining elements.\n\n遍历给出的数组，使用`Array.prototype.slice()`来去除数组尾部的元素，直到遇到给出的函数作用后返回`true`的元素。返回剩余元素。\n"
  },
  "dropWhile": {
    "prefix": "30s_dropWhile",
    "body": [
      "const dropWhile = (arr, func) => {",
      "  while (arr.length > 0 && !func(arr[0])) arr = arr.slice(1);",
      "  return arr;",
      "};"
    ],
    "description": "Removes elements in an array until the passed function returns `true`. Returns the remaining elements in the array.\n\n从数组中删掉给出的函数作用后返回`false`的元素（从头部开始），直到遇到第一个返回`true`的。返回数组的剩余元素。\n\nLoop through the array, using `Array.prototype.slice()` to drop the first element of the array until the returned value from the function is `true`.\nReturns the remaining elements.\n\n遍历给出的数组，使用`Array.prototype.slice()`来去除数组头部的元素，直到遇到给出的函数作用后返回`true`的元素。返回剩余元素。\n"
  },
  "elementContains": {
    "prefix": "30s_elementContains",
    "body": [
      "const elementContains = (parent, child) => parent !== child && parent.contains(child);"
    ],
    "description": "Returns `true` if the `parent` element contains the `child` element, `false` otherwise.\n\n如果给出的`parent`包含了给出的`child`元素则返回`true`，否则返回`false`。\n\nCheck that `parent` is not the same element as `child`, use `parent.contains(child)` to check if the `parent` element contains the `child` element.\n\n先检查`parent`是不是和`child`一样，使用`parent.contains(child)`来检查`parent`元素是不是包含`child`元素。\n"
  },
  "elementIsVisibleInViewport": {
    "prefix": "30s_elementIsVisibleInViewport",
    "body": [
      "const elementIsVisibleInViewport = (el, partiallyVisible = false) => {",
      "  const { top, left, bottom, right } = el.getBoundingClientRect();",
      "  const { innerHeight, innerWidth } = window;",
      "  return partiallyVisible",
      "    ? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) &&",
      "        ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth))",
      "    : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;",
      "};"
    ],
    "description": "Returns `true` if the element specified is visible in the viewport, `false` otherwise.\n\n如果给定的元素在可视区域中可见则返回`true`，否则返回`false`。\n\nUse `Element.getBoundingClientRect()` and the `window.inner(Width|Height)` values\nto determine if a given element is visible in the viewport.\nOmit the second argument to determine if the element is entirely visible, or specify `true` to determine if\nit is partially visible.\n\n使用`Element.getBoundingClientRect()`和`window.inner(Width|Height)`值来确定给定的元素在可视区域是否可见。如果不传第二个参数来决定元素是否要求完全可见（全部都在可视区域），则用`true`作为默认值，只要求元素部分可见。\n"
  },
  "elo": {
    "prefix": "30s_elo",
    "body": [
      "const elo = ([...ratings], kFactor = 32, selfRating) => {",
      "  const [a, b] = ratings;",
      "  const expectedScore = (self, opponent) => 1 / (1 + 10 ** ((opponent - self) / 400));",
      "  const newRating = (rating, i) =>",
      "    (selfRating || rating) + kFactor * (i - expectedScore(i ? a : b, i ? b : a));",
      "  if (ratings.length === 2) return [newRating(a, 1), newRating(b, 0)];",
      "",
      "  for (let i = 0, len = ratings.length; i < len; i++) {",
      "    let j = i;",
      "    while (j < len - 1) {",
      "      j++;",
      "      [ratings[i], ratings[j]] = elo([ratings[i], ratings[j]], kFactor);",
      "    }",
      "  }",
      "  return ratings;",
      "};"
    ],
    "description": "Computes the new ratings between two or more opponents using the [Elo rating system](https://en.wikipedia.org/wiki/Elo_rating_system). It takes an array\nof pre-ratings and returns an array containing post-ratings.\nThe array should be ordered from best performer to worst performer (winner -> loser).\n\n使用[Elo rating system](https://en.wikipedia.org/wiki/Elo_rating_system)计算两个或更多竞争者的新评分。接收一个之前评分的数组，并返回一个包含之后评分的数组。数组应该以最优到最差的顺序排序（胜者->败者）。\n\nUse the exponent `**` operator and math operators to compute the expected score (chance of winning).\nof each opponent and compute the new rating for each.\nLoop through the ratings, using each permutation to compute the post-Elo rating for each player in a pairwise fashion. \nOmit the second argument to use the default `kFactor` of 32.\n\n使用指数操作符`**`和数学操作符来计算期望的分值（获胜概率）。每个竞争者都计算新的评分。遍历排序列表，使用每种排列来计算成对方式的每个选手的后Elo评分。如果不传第二个参数`kFactor`，默认值为32。\n"
  },
  "equals": {
    "prefix": "30s_equals",
    "body": [
      "const equals = (a, b) => {",
      "  if (a === b) return true;",
      "  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();",
      "  if (!a || !b || (typeof a !== 'object' && typeof b !== 'object')) return a === b;",
      "  if (a.prototype !== b.prototype) return false;",
      "  let keys = Object.keys(a);",
      "  if (keys.length !== Object.keys(b).length) return false;",
      "  return keys.every(k => equals(a[k], b[k]));",
      "};"
    ],
    "description": "Performs a deep comparison between two values to determine if they are equivalent.\n\n在两个值之间执行深度比较来确定它们是否相等。\n\nCheck if the two values are identical, if they are both `Date` objects with the same time, using `Date.getTime()` or if they are both non-object values with an equivalent value (strict comparison).\nCheck if only one value is `null` or `undefined` or if their prototypes differ.\nIf none of the above conditions are met, use `Object.keys()` to check if both values have the same number of keys, then use `Array.prototype.every()` to check if every key in the first value exists in the second one and if they are equivalent by calling this method recursively.\n\n检测两个值是否相等，如果它们都是拥有相同时间的`Date`对象，使用`Date.getTime()`或者它们都是拥有相同值的非对象类型值(使用严格比较)。检测是否只有一个值为`null`或者`undefined`，或者它们的属性是否不同。如果以上场景都没有出现，使用`Object.keys()`来检查是否每个值都有相同数目的键，然后用`Array.prototype.every()`来检测第一个值中的每个键是否都在第二个值中存在，递归调用这套方法来确定它们是否深度相等。\n"
  },
  "escapeHTML": {
    "prefix": "30s_escapeHTML",
    "body": [
      "const escapeHTML = str =>",
      "  str.replace(",
      "    /[&<>'\"]/g,",
      "    tag =>",
      "      ({",
      "        '&': '&amp;',",
      "        '<': '&lt;',",
      "        '>': '&gt;',",
      "        \"'\": '&#39;',",
      "        '\"': '&quot;'",
      "      }[tag] || tag)",
      "  );"
    ],
    "description": "Escapes a string for use in HTML.\n\n转译一个HTML中使用的字符串（转换HTML实例）。\n\nUse `String.prototype.replace()` with a regexp that matches the characters that need to be escaped, using a callback function to replace each character instance with its associated escaped character using a dictionary (object).\n\n使用`String.prototype.replace()`和一个匹配需要转义的字符的正则表达式，还有一个回调函数来用相应的转义后的字符串（通过一个字典对象匹配）替换每个字符实例。\n"
  },
  "escapeRegExp": {
    "prefix": "30s_escapeRegExp",
    "body": [
      "const escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');"
    ],
    "description": "Escapes a string to use in a regular expression.\n\n转义一个在正则表达式中使用的字符串。\n\nUse `String.prototype.replace()` to escape special characters.\n\n使用`String.prototype.replace()`来转义特殊字符。\n"
  },
  "everyNth": {
    "prefix": "30s_everyNth",
    "body": [
      "const everyNth = (arr, nth) => arr.filter((e, i) => i % nth === nth - 1);"
    ],
    "description": "Returns every nth element in an array.\n\n遍历数组，返回每第`nth`个数（隔`nth-1`取一个数，返回它们组成的数组）。\n\nUse `Array.prototype.filter()` to create a new array that contains every nth element of a given array.\n\n使用`Array.prototype.filter()`创建一个包含所给数组中每个第`nth`个数的数组。\n"
  },
  "extendHex": {
    "prefix": "30s_extendHex",
    "body": [
      "const extendHex = shortHex =>",
      "  '#' +",
      "  shortHex",
      "    .slice(shortHex.startsWith('#') ? 1 : 0)",
      "    .split('')",
      "    .map(x => x + x)",
      "    .join('');"
    ],
    "description": "Extends a 3-digit color code to a 6-digit color code.\n\n把3位的颜色码扩充到6位颜色码。\n\nUse `Array.prototype.map()`, `String.prototype.split()` and `Array.prototype.join()` to join the mapped array for converting a 3-digit RGB notated hexadecimal color-code to the 6-digit form.\n`Array.prototype.slice()` is used to remove `#` from string start since it's added once.\n\n使用`Array.prototype.map()`, `String.prototype.split()`和`Array.prototype.join()`来把映射的数组连结起来，用来把3位的RGB形式的十六进制颜色码转为6位格式。\n"
  },
  "factorial": {
    "prefix": "30s_factorial",
    "body": [
      "const factorial = n =>",
      "  n < 0",
      "    ? (() => {",
      "      throw new TypeError('Negative numbers are not allowed!');",
      "    })()",
      "    : n <= 1",
      "      ? 1",
      "      : n * factorial(n - 1);"
    ],
    "description": "Calculates the factorial of a number.\n\n计算一个数的阶乘。\n\nUse recursion.\nIf `n` is less than or equal to `1`, return `1`.\nOtherwise, return the product of `n` and the factorial of `n - 1`.\nThrows an exception if `n` is a negative number.\n\n使用递归。如果`n`小于或等于`1`，则返回`1`。否则返回`n`和`n-1`的阶乘的乘积。如果`n`是一个负数则抛出一个异常。\n"
  },
  "fibonacci": {
    "prefix": "30s_fibonacci",
    "body": [
      "const fibonacci = n =>",
      "  Array.from({ length: n }).reduce(",
      "    (acc, val, i) => acc.concat(i > 1 ? acc[i - 1] + acc[i - 2] : i),",
      "    []",
      "  );"
    ],
    "description": "Generates an array, containing the Fibonacci sequence, up until the nth term.\n\n生成一个包含直到nth终结的斐波那契数列的数组。\n\nCreate an empty array of the specific length, initializing the first two values (`0` and `1`).\nUse `Array.prototype.reduce()` to add values into the array, using the sum of the last two values, except for the first two.\n\n创建一个指定长度的空数组，用(`0`和`1`)初始前两个值。使用`Array.prototype.reduce()`把最后两个值的和添加值到数组中，除了最开始两个数的。\n"
  },
  "filterFalsy": {
    "prefix": "30s_filterFalsy",
    "body": [
      "const filterFalsy = arr => arr.filter(Boolean);"
    ],
    "description": "Filters out the falsy values in an array.\n\n过滤掉一个数组中的假值。\n\nUse `Array.prototype.filter()` to get an array containing only truthy values.\n\n使用`Array.prototype.filter()`来获取一个只包含真值的数组。\n"
  },
  "filterNonUnique": {
    "prefix": "30s_filterNonUnique",
    "body": [
      "const filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));"
    ],
    "description": "Filters out the non-unique values in an array.\n\n过滤掉数组中不唯一的数。\n\nUse `Array.prototype.filter()` for an array containing only the unique values.\n\n使用`Array.prototype.filter()`过滤出一个只包含唯一值得数组。\n"
  },
  "filterNonUniqueBy": {
    "prefix": "30s_filterNonUniqueBy",
    "body": [
      "const filterNonUniqueBy = (arr, fn) =>",
      "  arr.filter((v, i) => arr.every((x, j) => (i === j) === fn(v, x, i, j)));"
    ],
    "description": "Filters out the non-unique values in an array, based on a provided comparator function.\n\n过滤掉数组中不唯一的数，唯一性通过给定的对比函数判断。\n\nUse `Array.prototype.filter()` and `Array.prototype.every()` for an array containing only the unique values, based on the comparator function, `fn`.\nThe comparator function takes four arguments: the values of the two elements being compared and their indexes.\n\n使用`Array.prototype.filter()` 和 `Array.prototype.every()`来创建一个只包含基于比较函数`fn`判定为唯一值的数组。比较函数有四个参数：两个比较的元素和他们的序号（index）。\n"
  },
  "findKey": {
    "prefix": "30s_findKey",
    "body": [
      "const findKey = (obj, fn) => Object.keys(obj).find(key => fn(obj[key], key, obj));"
    ],
    "description": "Returns the first key that satisfies the provided testing function. Otherwise `undefined` is returned.\n\n返回满足给定的测试函数的第一个键。否则返回`undefined`。\n\nUse `Object.keys(obj)` to get all the properties of the object, `Array.prototype.find()` to test the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.\n\n使用`Object.keys(obj)`来获取对象所有属性， `Array.prototype.find()`来对每个键值对测试指定的函数。回调函数接受三个参数——值，键，和对象。\n"
  },
  "findLast": {
    "prefix": "30s_findLast",
    "body": [
      "const findLast = (arr, fn) => arr.filter(fn).pop();"
    ],
    "description": "Returns the last element for which the provided function returns a truthy value.\n\n返回最后一个被给定函数作用后返回真值的元素。\n\nUse `Array.prototype.filter()` to remove elements for which `fn` returns falsy values, `Array.prototype.pop()` to get the last one.\n\n使用`Array.prototype.filter()`过滤掉`fn`作用后返回假值的元素，再使用`Array.prototype.pop()`来获取其中最后一个元素。\n"
  },
  "findLastIndex": {
    "prefix": "30s_findLastIndex",
    "body": [
      "const findLastIndex = (arr, fn) =>",
      "  (arr",
      "    .map((val, i) => [i, val])",
      "    .filter(([i, val]) => fn(val, i, arr))",
      "    .pop() || [-1])[0];"
    ],
    "description": "Returns the index of the last element for which the provided function returns a truthy value.\n\n返回被给定函数作用后返回真值的元素的序号。\n\nUse `Array.prototype.map()` to map each element to an array with its index and value.\nUse `Array.prototype.filter()` to remove elements for which `fn` returns falsy values, `Array.prototype.pop()` to get the last one.\n`-1` is the default value when not found.\n\n使用`Array.prototype.map()`来遍历数组中每个元素的序号和值。使用`Array.prototype.filter()`来过滤掉`fn`作用后返回假值的元素，再使用`Array.prototype.pop()`来获取其中最后一个元素。\n"
  },
  "findLastKey": {
    "prefix": "30s_findLastKey",
    "body": [
      "const findLastKey = (obj, fn) =>",
      "  Object.keys(obj)",
      "    .reverse()",
      "    .find(key => fn(obj[key], key, obj));"
    ],
    "description": "Returns the last key that satisfies the provided testing function.\nOtherwise `undefined` is returned.\n\n返回满足给定测试函数的最后一个键。否则返回`undefined`。\n\nUse `Object.keys(obj)` to get all the properties of the object, `Array.prototype.reverse()` to reverse their order and `Array.prototype.find()` to test the provided function for each key-value pair.\nThe callback receives three arguments - the value, the key and the object.\n\n使用`Object.keys(obj)`来获取对象所有属性，使用`Array.prototype.reverse()`来倒转它们的顺序，使用`Array.prototype.find()`来对每个键值对测试指定的函数。回调函数接受三个参数——值，键，和对象。\n"
  },
  "flatten": {
    "prefix": "30s_flatten",
    "body": [
      "const flatten = (arr, depth = 1) =>",
      "  arr.reduce((a, v) => a.concat(depth > 1 && Array.isArray(v) ? flatten(v, depth - 1) : v), []);"
    ],
    "description": "Flattens an array up to the specified depth.\n\n按照给定的最大深度扁平化数组。\n\nUse recursion, decrementing `depth` by 1 for each level of depth.\nUse `Array.prototype.reduce()` and `Array.prototype.concat()` to merge elements or arrays.\nBase case, for `depth` equal to `1` stops recursion.\nOmit the second argument, `depth` to flatten only to a depth of `1` (single flatten).\n\n使用递归，每一层递归`depth`自减1。使用`Array.prototype.reduce()`和`Array.prototype.concat()`来合并元素列表或数组。最基本的例子——`depth`为1时就停止递归。如果不传第二个参数，`depth`默认为1(单维度的扁平化)。\n"
  },
  "flattenObject": {
    "prefix": "30s_flattenObject",
    "body": [
      "const flattenObject = (obj, prefix = '') =>",
      "  Object.keys(obj).reduce((acc, k) => {",
      "    const pre = prefix.length ? prefix + '.' : '';",
      "    if (typeof obj[k] === 'object') Object.assign(acc, flattenObject(obj[k], pre + k));",
      "    else acc[pre + k] = obj[k];",
      "    return acc;",
      "  }, {});"
    ],
    "description": "Flatten an object with the paths for keys.\n\n用路径和键列表的方式把一个对象扁平化。（路径就是用`.`分隔对象层级）\n\nUse recursion.\nUse `Object.keys(obj)` combined with `Array.prototype.reduce()` to convert every leaf node to a flattened path node.\nIf the value of a key is an object, the function calls itself with the appropriate `prefix` to create the path using `Object.assign()`.\nOtherwise, it adds the appropriate prefixed key-value pair to the accumulator object.\nYou should always omit the second argument, `prefix`, unless you want every key to have a prefix.\n\n使用递归。使用`Object.keys(obj)`和`Array.prototype.reduce()`来把每一个叶子节点转换为扁平化路径节点。如果这个键的值是一个对象，这个函数则使用`Object.assign()`来用合适的`prefix`调用自己来创建一个路径。否则，它把合适的前缀键值对添加到累加器中。除非你想要每个键都有一个前缀，否则你应该总是不传第二个参数`prefix`。\n"
  },
  "flip": {
    "prefix": "30s_flip",
    "body": [
      "const flip = fn => (first, ...rest) => fn(...rest, first);"
    ],
    "description": "Flip takes a function as an argument, then makes the first argument the last.\n\nFlip接受一个函数作为参数，把传入函数的第一个参数放到参数列表末尾。\n\nReturn a closure that takes variadic inputs, and splices the last argument to make it the first argument before applying the rest.\n\n返回一个接受可变数量参数，把第一个参数放到其余参数后面（即最后）的闭包（英文好像有错误）\n"
  },
  "forEachRight": {
    "prefix": "30s_forEachRight",
    "body": [
      "const forEachRight = (arr, callback) =>",
      "  arr",
      "    .slice(0)",
      "    .reverse()",
      "    .forEach(callback);"
    ],
    "description": "Executes a provided function once for each array element, starting from the array's last element.\n\n从数组中最后一个元素开始，对数组中每个元素执行给定的函数。\n\nUse `Array.prototype.slice(0)` to clone the given array, `Array.prototype.reverse()` to reverse it and `Array.prototype.forEach()` to iterate over the reversed array.\n\n使用`Array.prototype.slice(0)`来克隆给定的数组，使用`Array.prototype.reverse()`来翻转数组，使用`Array.prototype.forEach()`遍历翻转后的数组。\n"
  },
  "formatDuration": {
    "prefix": "30s_formatDuration",
    "body": [
      "const formatDuration = ms => {",
      "  if (ms < 0) ms = -ms;",
      "  const time = {",
      "    day: Math.floor(ms / 86400000),",
      "    hour: Math.floor(ms / 3600000) % 24,",
      "    minute: Math.floor(ms / 60000) % 60,",
      "    second: Math.floor(ms / 1000) % 60,",
      "    millisecond: Math.floor(ms) % 1000",
      "  };",
      "  return Object.entries(time)",
      "    .filter(val => val[1] !== 0)",
      "    .map(([key, val]) => `${val} ${key}${val !== 1 ? 's' : ''}`)",
      "    .join(', ');",
      "};"
    ],
    "description": "Returns the human readable format of the given number of milliseconds.\n\n返回一个给定毫秒数值的可读格式。\n\nDivide `ms` with the appropriate values to obtain the appropriate values for `day`, `hour`, `minute`, `second` and `millisecond`.\nUse `Object.entries()` with `Array.prototype.filter()` to keep only non-zero values.\nUse `Array.prototype.map()` to create the string for each value, pluralizing appropriately.\nUse `String.prototype.join(', ')` to combine the values into a string.\n\n把`ms`分为易于处理的`day`, `hour`, `minute`, `second`和`millisecond`几个值。使用`Object.entries()`和`Array.prototype.filter()`来只保留非零值。使用`Array.prototype.map()`来为每个值创建一个字符串，变为合适的复数形式。使用`String.prototype.join(', ')`把生成的值合并成一个字符串。\n"
  },
  "formToObject": {
    "prefix": "30s_formToObject",
    "body": [
      "const formToObject = form =>",
      "  Array.from(new FormData(form)).reduce(",
      "    (acc, [key, value]) => ({",
      "      ...acc,",
      "      [key]: value",
      "    }),",
      "    {}",
      "  );"
    ],
    "description": "Encode a set of form elements as an `object`.\n\nUse the `FormData` constructor to convert the HTML `form` to `FormData`, `Array.from()` to convert to an array.\nCollect the object from the array, using `Array.prototype.reduce()`.\n"
  },
  "forOwn": {
    "prefix": "30s_forOwn",
    "body": [
      "const forOwn = (obj, fn) => Object.keys(obj).forEach(key => fn(obj[key], key, obj));"
    ],
    "description": "Iterates over all own properties of an object, running a callback for each one.\n\n对对象中每个自有属性都迭代的执行一个回调。\n\nUse `Object.keys(obj)` to get all the properties of the object, `Array.prototype.forEach()` to run the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.\n\n使用`Object.keys(obj)`来获取对象的属性列表，`Array.prototype.forEach()`来对每个键值对运行给定的函数。回调函数接受三个参数——值，键，和对象。\n"
  },
  "forOwnRight": {
    "prefix": "30s_forOwnRight",
    "body": [
      "const forOwnRight = (obj, fn) =>",
      "  Object.keys(obj)",
      "    .reverse()",
      "    .forEach(key => fn(obj[key], key, obj));"
    ],
    "description": "Iterates over all own properties of an object in reverse, running a callback for each one.\n\n反向的对对象中每个自有属性（按照默认顺序相反的顺序）都迭代的执行一个回调。\n\nUse `Object.keys(obj)` to get all the properties of the object, `Array.prototype.reverse()` to reverse their order and `Array.prototype.forEach()` to run the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.\n\n使用`Object.keys(obj)`来获取对象的每个属性，使用`Array.prototype.reverse()`来反转它们的顺序，`Array.prototype.forEach()`来对每个键值对运行给定的函数。回调函数接受三个参数——值，键，和对象。\n"
  },
  "frequencies": {
    "prefix": "30s_frequencies",
    "body": [
      "const frequencies = arr =>",
      "  arr.reduce((a, v) => {",
      "    a[v] = a[v] ? a[v] + 1 : 1;",
      "    return a;",
      "  }, {});"
    ],
    "description": "Returns an object with the unique values of an array as keys and their frequencies as the values.\n\nUse `Array.prototype.reduce()` to map unique values to an object's keys, adding to existing keys every time the same value is encountered.\n"
  },
  "fromCamelCase": {
    "prefix": "30s_fromCamelCase",
    "body": [
      "const fromCamelCase = (str, separator = '_') =>",
      "  str",
      "    .replace(/([a-z\\d])([A-Z])/g, '$1' + separator + '$2')",
      "    .replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + separator + '$2')",
      "    .toLowerCase();"
    ],
    "description": "Converts a string from camelcase.\n\n从驼峰写法的字符串转换出一个字符串。\n\nUse `String.prototype.replace()` to remove underscores, hyphens, and spaces and convert words to camelcase.\nOmit the second argument to use a default `separator` of `_`.\n\n使用`String.prototype.replace()`来去掉下划线、连字符，还有空白字符，并把每个词转换为驼峰的。如果不传第二个参数，默认`separator`为`_`。（这段说明应该说的是驼峰化，反了）\n"
  },
  "functionName": {
    "prefix": "30s_functionName",
    "body": [
      "const functionName = fn => (console.debug(fn.name), fn);"
    ],
    "description": "Logs the name of a function.\n\n打印出函数的名称。\n\nUse `console.debug()` and the `name` property of the passed method to log the method's name to the `debug` channel of the console.\n\n使用`console.debug()`和传入方法的`name`属性来把方法的名称输出到console的`debug`通道。\n"
  },
  "functions": {
    "prefix": "30s_functions",
    "body": [
      "const functions = (obj, inherited = false) =>",
      "  (inherited",
      "    ? [...Object.keys(obj), ...Object.keys(Object.getPrototypeOf(obj))]",
      "    : Object.keys(obj)",
      "  ).filter(key => typeof obj[key] === 'function');"
    ],
    "description": "Returns an array of function property names from own (and optionally inherited) enumerable properties of an object.\n\n从一个对象的自有的（可选的从继承属性）可枚举属性中返回一个函数属性名字的数组。\n\nUse `Object.keys(obj)` to iterate over the object's own properties.\nIf `inherited` is `true`, use `Object.get.PrototypeOf(obj)` to also get the object's inherited properties.\nUse `Array.prototype.filter()` to keep only those properties that are functions.\nOmit the second argument, `inherited`, to not include inherited properties by default.\n\n使用`Object.keys(obj)`来迭代对象的每个自有属性。如果`inherited`参数为`true`，使用`Object.getPrototypeOf(obj)`把对象的继承属性也获取到。使用`Array.prototype.filter()`来只保留那些是函数的属性。如果不传第二个参数`inherited`，则默认不包含继承属性。\n"
  },
  "gcd": {
    "prefix": "30s_gcd",
    "body": [
      "const gcd = (...arr) => {",
      "  const _gcd = (x, y) => (!y ? x : gcd(y, x % y));",
      "  return [...arr].reduce((a, b) => _gcd(a, b));",
      "};"
    ],
    "description": "Calculates the greatest common divisor between two or more numbers/arrays.\n\n计算两个或多个数组或数组的最大公因数。\n\nThe inner `_gcd` function uses recursion.\nBase case is when `y` equals `0`. In this case, return `x`.\nOtherwise, return the GCD of `y` and the remainder of the division `x/y`.\n\n内部的`_gcd`函数使用递归。基本情况是当`y`等于`0`，这种情况返回`x`。否则返回`y`的GCD和`x/y`的余数。\n"
  },
  "geometricProgression": {
    "prefix": "30s_geometricProgression",
    "body": [
      "const geometricProgression = (end, start = 1, step = 2) =>",
      "  Array.from({ length: Math.floor(Math.log(end / start) / Math.log(step)) + 1 }).map(",
      "    (v, i) => start * step ** i",
      "  );"
    ],
    "description": "Initializes an array containing the numbers in the specified range where `start` and `end` are inclusive and the ratio between two terms is `step`.\nReturns an error if `step` equals `1`.\n\n范围通过`start`和`end`指定，两个点之间的比值通过`step`指定，初始化一个数组（即生成一个等比数列）。\n\nUse `Array.from()`, `Math.log()` and `Math.floor()` to create an array of the desired length, `Array.prototype.map()` to fill with the desired values in a range.\nOmit the second argument, `start`, to use a default value of `1`.\nOmit the third argument, `step`, to use a default value of `2`.\n\n使用`Array.from()`，`Math.log()` 和 `Math.floor()`来创建一个期望长度的数组，用`Array.prototype.map()`来给它填充上期望的值。如果不传第二个参数`start`，默认值为`1`；如果不传第三个参数`step`，默认值为`2`。\n"
  },
  "get": {
    "prefix": "30s_get",
    "body": [
      "const get = (from, ...selectors) =>",
      "  [...selectors].map(s =>",
      "    s",
      "      .replace(/\\[([^\\[\\]]*)\\]/g, '.$1.')",
      "      .split('.')",
      "      .filter(t => t !== '')",
      "      .reduce((prev, cur) => prev && prev[cur], from)",
      "  );"
    ],
    "description": "Retrieve a set of properties indicated by the given selectors from an object.\n\n从一个对象中使用给出的选择器获取一个指定属性列表。\n\nUse `Array.prototype.map()` for each selector, `String.prototype.replace()` to replace square brackets with dots, `String.prototype.split('.')` to split each selector, `Array.prototype.filter()` to remove empty values and `Array.prototype.reduce()` to get the value indicated by it.\n\n使用`Array.prototype.map()` 遍历每个selector，使用`String.prototype.replace()`来用点来替换方括号，`String.prototype.split('.')`来拆分每个选择器，使用`Array.prototype.filter()`来把空值删除，然后使用`Array.prototype.reduce()`来获取被它指定的值。\n"
  },
  "getColonTimeFromDate": {
    "prefix": "30s_getColonTimeFromDate",
    "body": [
      "const getColonTimeFromDate = date => date.toTimeString().slice(0, 8);"
    ],
    "description": "Returns a string of the form `HH:MM:SS` from a `Date` object.\n\n返回一个`Date`对象的`HH:MM:SS`形式字符串。\n\nUse `Date.prototype.toTimeString()` and `String.prototype.slice()` to get the `HH:MM:SS` part of a given `Date` object.\n\n使用`Date.prototype.toTimeString()`和`String.prototype.slice()`来获取给定`Date`的`HH:MM:SS`部分。\n"
  },
  "getDaysDiffBetweenDates": {
    "prefix": "30s_getDaysDiffBetweenDates",
    "body": [
      "const getDaysDiffBetweenDates = (dateInitial, dateFinal) =>",
      "  (dateFinal - dateInitial) / (1000 * 3600 * 24);"
    ],
    "description": "Returns the difference (in days) between two dates.\n\n返回两个时间对象的日期上的差值。\n\nCalculate the difference (in days) between two `Date` objects.\n\n计算两个时间对象的日期上的差值。\n"
  },
  "getImages": {
    "prefix": "30s_getImages",
    "body": [
      "const getImages = (el, includeDuplicates = false) => {",
      "  const images = [...el.getElementsByTagName('img')].map(img => img.getAttribute('src'));",
      "  return includeDuplicates ? images : [...new Set(images)];",
      "};"
    ],
    "description": "Fetches all images from within an element and puts them into an array\n\n把一个元素内部所有的image都找到，并把它们放到一个数组中。\n\nUse `Element.prototype.getElementsByTagName()` to fetch all `<img>` elements inside the provided element, `Array.prototype.map()` to map every `src` attribute of their respective `<img>` element, then create a `Set` to eliminate duplicates and return the array.\n\n使用`Element.prototype.getElementsByTagName()`来获取给定元素内部的所有的`<img>`元素，用`Array.prototype.map()`来分别获取`<img>`元素对应的每一个`src`属性，然后创建一个`Set`来去除重复数据并返回一个数组。\n"
  },
  "getMeridiemSuffixOfInteger": {
    "prefix": "30s_getMeridiemSuffixOfInteger",
    "body": [
      "const getMeridiemSuffixOfInteger = num =>",
      "  num === 0 || num === 24",
      "    ? 12 + 'am'",
      "    : num === 12",
      "      ? 12 + 'pm'",
      "      : num < 12",
      "        ? (num % 12) + 'am'",
      "        : (num % 12) + 'pm';"
    ],
    "description": "Converts an integer to a suffixed string, adding `am` or `pm` based on its value.\n\n把一个整数转为带后缀的字符串，根据它们的值来添加`am`或者`pm`（添加到后面）。\n\nUse the modulo operator (`%`) and conditional checks to transform an integer to a stringified 12-hour format with meridiem suffix.\n\n使用取模操作符(`%`)和条件运算符来把一个整数转换为12小时制的子午线后缀字符串形式。\n"
  },
  "getScrollPosition": {
    "prefix": "30s_getScrollPosition",
    "body": [
      "const getScrollPosition = (el = window) => ({",
      "  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,",
      "  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop",
      "});"
    ],
    "description": "Returns the scroll position of the current page.\n\n返回当前页面的滚动位置。\n\nUse `pageXOffset` and `pageYOffset` if they are defined, otherwise `scrollLeft` and `scrollTop`.\nYou can omit `el` to use a default value of `window`.\n\n如果`pageXOffset`和`pageYOffset`有定义则使用它们，否则用`scrollLeft`和`scrollTop`。你可以不传`el`参数来使用默认值`window`。\n"
  },
  "getStyle": {
    "prefix": "30s_getStyle",
    "body": [
      "const getStyle = (el, ruleName) => getComputedStyle(el)[ruleName];"
    ],
    "description": "Returns the value of a CSS rule for the specified element.\n\n返回指定元素的CSS规则值（style）。\n\nUse `Window.getComputedStyle()` to get the value of the CSS rule for the specified element.\n\n使用`Window.getComputedStyle()`来获取指定元素的CSS规则值（style）。\n"
  },
  "getType": {
    "prefix": "30s_getType",
    "body": [
      "const getType = v =>",
      "  v === undefined ? 'undefined' : v === null ? 'null' : v.constructor.name.toLowerCase();"
    ],
    "description": "Returns the native type of a value.\n\n返回值的原生类型。\n\nReturns lowercased constructor name of value, `\"undefined\"` or `\"null\"` if value is `undefined` or `null`.\n\n返回值的小写形式的构造器名称，如果值是`undefined`或`null`则返回`\"undefined\"`或`\"null\"`。\n"
  },
  "getURLParameters": {
    "prefix": "30s_getURLParameters",
    "body": [
      "const getURLParameters = url =>",
      "  (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce(",
      "    (a, v) => ((a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a),",
      "    {}",
      "  );"
    ],
    "description": "Returns an object containing the parameters of the current URL.\n\n返回一个包含当前URL的参数的对象。\n\nUse `String.match()` with an appropriate regular expression to get all key-value pairs, `Array.prototype.reduce()` to map and combine them into a single object.\nPass `location.search` as the argument to apply to the current `url`.\n\n使用`String.match()`和一个合适的正则表达式来获取所有键值对，使用`Array.prototype.reduce()`来映射并把它们组合成一个单一对象。把`location.search`作为参数传入以应用到当前的`url`参数。\n"
  },
  "groupBy": {
    "prefix": "30s_groupBy",
    "body": [
      "const groupBy = (arr, fn) =>",
      "  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val, i) => {",
      "    acc[val] = (acc[val] || []).concat(arr[i]);",
      "    return acc;",
      "  }, {});"
    ],
    "description": "Groups the elements of an array based on the given function.\n\n根据给定的函数对数组中的元素分组。\n\nUse `Array.prototype.map()` to map the values of an array to a function or property name.\nUse `Array.prototype.reduce()` to create an object, where the keys are produced from the mapped results.\n\n使用`Array.prototype.map()`来遍历数组，获取应用给定的函数或者获取指定的属性值。使用`Array.prototype.reduce()`来创建一个对象，它的键名是从映射结果中获取的。\n"
  },
  "hammingDistance": {
    "prefix": "30s_hammingDistance",
    "body": [
      "const hammingDistance = (num1, num2) => ((num1 ^ num2).toString(2).match(/1/g) || '').length;"
    ],
    "description": "Calculates the Hamming distance between two values.\n\n计算两个值之间的汉明距离。\n\nUse XOR operator (`^`) to find the bit difference between the two numbers, convert to a binary string using `toString(2)`.\nCount and return the number of `1`s in the string, using `match(/1/g)`.\n\n使用异或操作符(`^`)来找到两个数之间的bit位差异，用`toString(2)`把它转换二进制字符串。使用`match(/1/g)`计算并返回字符串中`1`的数目。\n"
  },
  "hasClass": {
    "prefix": "30s_hasClass",
    "body": [
      "const hasClass = (el, className) => el.classList.contains(className);"
    ],
    "description": "Returns `true` if the element has the specified class, `false` otherwise.\n\n如果元素有指定的class则返回`true`，否则返回`false`。\n\nUse `element.classList.contains()` to check if the element has the specified class.\n\n使用`element.classList.contains()`检查给出的元素是否有指定的class。\n"
  },
  "hasFlags": {
    "prefix": "30s_hasFlags",
    "body": [
      "const hasFlags = (...flags) =>",
      "  flags.every(flag => process.argv.includes(/^-{1,2}/.test(flag) ? flag : '--' + flag));"
    ],
    "description": "Check if the current process's arguments contain the specified flags.\n\n检测当前的进程参数是否包含特定的标志（全部包含了才返回`true`）。\n\nUse `Array.prototype.every()` and `Array.prototype.includes()` to check if `process.argv` contains all the specified flags.\nUse a regular expression to test if the specified flags are prefixed with `-` or `--` and prefix them accordingly.\n\n使用`Array.prototype.every()`和`Array.prototype.includes()`来检查`process.argv`是否包含全部的特定标志。使用一个正则表达式来测试特定标志的前缀是`-`还是`--`并分别给它们添加前缀。\n"
  },
  "hashBrowser": {
    "prefix": "30s_hashBrowser",
    "body": [
      "const hashBrowser = val =>",
      "  crypto.subtle.digest('SHA-256', new TextEncoder('utf-8').encode(val)).then(h => {",
      "    let hexes = [],",
      "      view = new DataView(h);",
      "    for (let i = 0; i < view.byteLength; i += 4)",
      "      hexes.push(('00000000' + view.getUint32(i).toString(16)).slice(-8));",
      "    return hexes.join('');",
      "  });"
    ],
    "description": "Creates a hash for a value using the [SHA-256](https://en.wikipedia.org/wiki/SHA-2) algorithm. Returns a promise.\n\n使用[SHA-256](https://en.wikipedia.org/wiki/SHA-2)算法创建一个hash。返回一个promise。\n\nUse the [SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto) API to create a hash for the given value.\n\n使用[SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)API来创建给定值的hash。\n"
  },
  "hashNode": {
    "prefix": "30s_hashNode",
    "body": [
      "const crypto = require('crypto');",
      "const hashNode = val =>",
      "  new Promise(resolve =>",
      "    setTimeout(",
      "      () =>",
      "        resolve(",
      "          crypto",
      "            .createHash('sha256')",
      "            .update(val)",
      "            .digest('hex')",
      "        ),",
      "      0",
      "    )",
      "  );"
    ],
    "description": "Creates a hash for a value using the [SHA-256](https://en.wikipedia.org/wiki/SHA-2) algorithm. Returns a promise.\n\n使用[SHA-256](https://en.wikipedia.org/wiki/SHA-2)算法为值创建hash。返回一个promise。\n\nUse `crypto` API to create a hash for the given value, `setTimeout` to prevent blocking on a long operation, and a `Promise` to give it a familiar interface.\n\n使用`crypto`API来为给定的值创建hash，使用`setTimeout`来避免长时间操作时阻塞，并使用`Promise`来给出一个通用接口。\n"
  },
  "hasKey": {
    "prefix": "30s_hasKey",
    "body": [
      "const hasKey = (obj, keys) => {",
      "  return (",
      "    keys.length > 0 &&",
      "    keys.every(key => {",
      "      if (typeof obj !== 'object' || !obj.hasOwnProperty(key)) return false;",
      "      obj = obj[key];",
      "      return true;",
      "    })",
      "  );",
      "};"
    ],
    "description": "Returns `true` if the target value exists in a JSON object, `false` otherwise.\n\nCheck if `keys` is non-empty and use `Array.prototype.every()` to sequentially check its keys to internal depth of the object, `obj`. \nUse `Object.prototype.hasOwnProperty()` to check if `obj` does not have the current key or is not an object, stop propagation and return `false`.\nOtherwise assign the key's value to `obj` to use on the next iteration.\nReturn `false` beforehand if given key list is empty.\n"
  },
  "haveSameContents": {
    "prefix": "30s_haveSameContents",
    "body": [
      "const haveSameContents = (a, b) => {",
      "  for (const v of new Set([...a, ...b]))",
      "    if (a.filter(e => e === v).length !== b.filter(e => e === v).length) return false;",
      "  return true;",
      "};"
    ],
    "description": "Returns `true` if two arrays contain the same elements regardless of order, `false` otherwise.\n\nUse a `for...of` loop over a `Set` created from the values of both arrays.\nUse `Array.prototype.filter()` to compare the amount of occurences of each distinct value in both arrays.\nReturn `false` if the counts do not match for any element, `true` otherwise.\n"
  },
  "head": {
    "prefix": "30s_head",
    "body": [
      "const head = arr => (arr && arr.length ? arr[0] : undefined);"
    ],
    "description": "Returns the head of a list.\n\nCheck if `arr` is truthy and has a `length` property, use `arr[0]` if possible to return the first element, otherwise return `undefined`.\n"
  },
  "hexToRGB": {
    "prefix": "30s_hexToRGB",
    "body": [
      "const hexToRGB = hex => {",
      "  let alpha = false,",
      "    h = hex.slice(hex.startsWith('#') ? 1 : 0);",
      "  if (h.length === 3) h = [...h].map(x => x + x).join('');",
      "  else if (h.length === 8) alpha = true;",
      "  h = parseInt(h, 16);",
      "  return (",
      "    'rgb' +",
      "    (alpha ? 'a' : '') +",
      "    '(' +",
      "    (h >>> (alpha ? 24 : 16)) +",
      "    ', ' +",
      "    ((h & (alpha ? 0x00ff0000 : 0x00ff00)) >>> (alpha ? 16 : 8)) +",
      "    ', ' +",
      "    ((h & (alpha ? 0x0000ff00 : 0x0000ff)) >>> (alpha ? 8 : 0)) +",
      "    (alpha ? `, ${h & 0x000000ff}` : '') +",
      "    ')'",
      "  );",
      "};"
    ],
    "description": "Converts a color code to a `rgb()` or `rgba()` string if alpha value is provided.\n\n则把一个颜色码转换为一个`rgb()`字符串，或者提供了alpha值时转换为`rgba()`字符串。\n\nUse bitwise right-shift operator and mask bits with `&` (and) operator to convert a hexadecimal color code (with or without prefixed with `#`) to a string with the RGB values. If it's 3-digit color code, first convert to 6-digit version. If an alpha value is provided alongside 6-digit hex, give `rgba()` string in return.\n\n使用向右位移操作符和掩码位还有`&`(相与)操作符来把十六进制的颜色码（有没有前缀的`#`都可以）转换为一个RGB值字符串。如果它是一个3位的颜色码，先转换为6位版本。如果随着6位十六进制提供了一个alpha值，则返回`rgba()`字符串。\n"
  },
  "hide": {
    "prefix": "30s_hide",
    "body": [
      "const hide = (...el) => [...el].forEach(e => (e.style.display = 'none'));"
    ],
    "description": "Hides all the elements specified.\n\n隐藏所有指定的元素。\n\nUse `NodeList.prototype.forEach()` to apply `display: none` to each element specified.\n\n使用`NodeList.prototype.forEach()`来对每个给定的元素应用`display: none`样式。\n"
  },
  "httpGet": {
    "prefix": "30s_httpGet",
    "body": [
      "const httpGet = (url, callback, err = console.error) => {",
      "  const request = new XMLHttpRequest();",
      "  request.open('GET', url, true);",
      "  request.onload = () => callback(request.responseText);",
      "  request.onerror = () => err(request);",
      "  request.send();",
      "};"
    ],
    "description": "Makes a `GET` request to the passed URL.\n\n创建一个到传入URL的`GET`请求。\n\nUse [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest) web api to make a `get` request to the given `url`.\nHandle the `onload` event, by calling the given `callback` the `responseText`.\nHandle the `onerror` event, by running the provided `err` function.\nOmit the third argument, `err`, to log errors to the console's `error` stream by default.\n\n使用[`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)网络api来创建一个给出`url`的`get`请求。通过对`responseText`调用给出的`callback`来处理`onload`事件，通过执行提供的`err`函数来处理`onerror`事件。如果不传第三个参数`err`，则把错误打印到默认的控制台`error`流中。\n"
  },
  "httpPost": {
    "prefix": "30s_httpPost",
    "body": [
      "const httpPost = (url, data, callback, err = console.error) => {",
      "  const request = new XMLHttpRequest();",
      "  request.open('POST', url, true);",
      "  request.setRequestHeader('Content-type', 'application/json; charset=utf-8');",
      "  request.onload = () => callback(request.responseText);",
      "  request.onerror = () => err(request);",
      "  request.send(data);",
      "};"
    ],
    "description": "Makes a `POST` request to the passed URL.\n\n创建一个到传入URL的`POST`请求。\n\nUse [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest) web api to make a `post` request to the given `url`.\nSet the value of an `HTTP` request header with `setRequestHeader` method.\nHandle the `onload` event, by calling the given `callback` the `responseText`.\nHandle the `onerror` event, by running the provided `err` function.\nOmit the third argument, `data`, to send no data to the provided `url`.\nOmit the fourth argument, `err`, to log errors to the console's `error` stream by default.\n\n使用[`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)网络api来创建一个给出`url`的`post`请求。用`setRequestHeader`方法来设置`HTTP`请求头。通过对`responseText`调用给出的`callback`来处理`onload`事件，通过执行提供的`err`函数来处理`onerror`事件。如果不传第三个参数`data`，则不向给出的`url`发送数据。如果不传第四个参数`err`，则把错误打印到默认的控制台`error`流中。\n"
  },
  "httpsRedirect": {
    "prefix": "30s_httpsRedirect",
    "body": [
      "const httpsRedirect = () => {",
      "  if (location.protocol !== 'https:') location.replace('https://' + location.href.split('//')[1]);",
      "};"
    ],
    "description": "Redirects the page to HTTPS if its currently in HTTP. Also, pressing the back button doesn't take it back to the HTTP page as its replaced in the history.\n\n如果当前页是HTTP的，则重定向到HTTPS。因为是在history中使用替换方法，所以点击回退按钮不会退回到上一个HTTP的页面。\n\nUse `location.protocol` to get the protocol currently being used. If it's not HTTPS, use `location.replace()` to replace the existing page with the HTTPS version of the page. Use `location.href` to get the full address, split it with `String.prototype.split()` and remove the protocol part of the URL.\n\n使用`location.protocol`获取当前页使用的协议。如果不是HTTPS的，使用`location.replace()`把当前页替换为它的HTTPS版本。使用`location.href`来获取地址全字段，用`String.prototype.split()`拆分它们并从URL中删除协议部分。\n"
  },
  "hz": {
    "prefix": "30s_hz",
    "body": [
      "const hz = (fn, iterations = 100) => {",
      "  const before = performance.now();",
      "  for (let i = 0; i < iterations; i++) fn();",
      "  return (1000 * iterations) / (performance.now() - before);",
      "};"
    ],
    "description": "Returns the number of times a function executed per second. \n`hz` is the unit for `hertz`, the unit of frequency defined as one cycle per second.\n\n返回一个函数每秒执行的次数。`hz`是`hertz`的单位，被定义为以每秒为一个周期的频率单位。\n\nUse `performance.now()` to get the difference in milliseconds before and after the iteration loop to calculate the time elapsed executing the function `iterations` times. \nReturn the number of cycles per second by converting milliseconds to seconds and dividing it by the time elapsed. \nOmit the second argument, `iterations`, to use the default of 100 iterations.\n\n使用`performance.now()`来获取迭代循环执行`iterations`次函数的执行时间的前后差值（以毫秒为单位）。把毫秒转换为秒并除以时间长度，返回每秒的循环次数。如果不传第二个参数`iterations`，默认值为循环100次。\n"
  },
  "includesAll": {
    "prefix": "30s_includesAll",
    "body": [
      "const includesAll = (arr, values) => values.every(v => arr.includes(v));"
    ],
    "description": "Returns `true` if all the elements ιν `values` are included in `arr`, `false` otherwise.\n\nUse `Array.prototype.every()` and `Array.prototype.includes()` to check if all elements of `values` are included in `arr`.\n"
  },
  "includesAny": {
    "prefix": "30s_includesAny",
    "body": [
      "const includesAny = (arr, values) => values.some(v => arr.includes(v));"
    ],
    "description": "Returns `true` if at least one element of values is included in arr , `false` otherwise.\n\nUse `Array.prototype.some()` and `Array.prototype.includes()` to check if at least one element of `values` is included in `arr`.\n"
  },
  "indentString": {
    "prefix": "30s_indentString",
    "body": [
      "const indentString = (str, count, indent = ' ') => str.replace(/^/gm, indent.repeat(count));"
    ],
    "description": "Indents each line in the provided string.\n\n缩进给定字符串的每一行。\n\nUse `String.replace` and a regular expression to add the character specified by `indent` `count` times at the start of each line.\nOmit the third parameter, `indent`, to use a default indentation character of `' '`.\n\n使用`String.replace`和一个正则表达式在每一行的开始添加指定的`indent``count`次的字符串。如果不传第三个参数`indent`，使用默认的缩进字符`' '`。\n"
  },
  "indexOfAll": {
    "prefix": "30s_indexOfAll",
    "body": [
      "const indexOfAll = (arr, val) => arr.reduce((acc, el, i) => (el === val ? [...acc, i] : acc), []);"
    ],
    "description": "Returns all indices of `val` in an array.\nIf `val` never occurs, returns `[]`.\n\n返回数组中所有`val`的序号列表。如果`val`没有出现，返回`[]`。\n\nUse `Array.prototype.reduce()` to loop over elements and store indices for matching elements.\nReturn the array of indices.\n\n使用`Array.prototype.reduce()`来遍历元素并把序号存到相应的列表中。返回序号数组。\n"
  },
  "initial": {
    "prefix": "30s_initial",
    "body": [
      "const initial = arr => arr.slice(0, -1);"
    ],
    "description": "Returns all the elements of an array except the last one.\n\n返回除最后一个元素的数组。\n\nUse `arr.slice(0,-1)` to return all but the last element of the array.\n\n使用`arr.slice(0,-1)`来返回排除了最后一个元素的数组。\n"
  },
  "initialize2DArray": {
    "prefix": "30s_initialize2DArray",
    "body": [
      "const initialize2DArray = (w, h, val = null) =>",
      "  Array.from({ length: h }).map(() => Array.from({ length: w }).fill(val));"
    ],
    "description": "Initializes a 2D array of given width and height and value.\n\n使用给定的宽、高和值初始化一个二维数组。\n\nUse `Array.prototype.map()` to generate h rows where each is a new array of size w initialize with value. If the value is not provided, default to `null`.\n\n使用`Array.prototype.map()`创建`h`行，每行都是一个使用`val`初始化的长度为`w`的数组。如果`val`不传，默认为`null`。\n"
  },
  "initializeArrayWithRange": {
    "prefix": "30s_initializeArrayWithRange",
    "body": [
      "const initializeArrayWithRange = (end, start = 0, step = 1) =>",
      "  Array.from({ length: Math.ceil((end - start + 1) / step) }, (v, i) => i * step + start);"
    ],
    "description": "Initializes an array containing the numbers in the specified range where `start` and `end` are inclusive with their common difference `step`.\n\n使用`start`到`end`范围内以`step`为步进的数字列表初始化一个数组。\n\nUse `Array.from()` to create an array of the desired length, `(end - start + 1)/step`, and a map function to fill it with the desired values in the given range.\nYou can omit `start` to use a default value of `0`.\nYou can omit `step` to use a default value of `1`.\n\n使用`Array.from()`创建一个期望长度`(end - start + 1)/step`的数组，并用使用指定范围内的值填充它。`start`默认值为`0`，`step`默认值为`1`。\n"
  },
  "initializeArrayWithRangeRight": {
    "prefix": "30s_initializeArrayWithRangeRight",
    "body": [
      "const initializeArrayWithRangeRight = (end, start = 0, step = 1) =>",
      "  Array.from({ length: Math.ceil((end + 1 - start) / step) }).map(",
      "    (v, i, arr) => (arr.length - i - 1) * step + start",
      "  );"
    ],
    "description": "Initializes an array containing the numbers in the specified range (in reverse) where `start` and `end` are inclusive with their common difference `step`.\n\n初始化一个包含`start`到`end`范围内以`step`为步进的数字列表的数组（倒序的）。\n\nUse `Array.from(Math.ceil((end+1-start)/step))` to create an array of the desired length(the amounts of elements is equal to `(end-start)/step` or `(end+1-start)/step` for inclusive end), `Array.prototype.map()` to fill with the desired values in a range.\nYou can omit `start` to use a default value of `0`.\nYou can omit `step` to use a default value of `1`.\n\n使用`Array.from(Math.ceil((end+1-start)/step))`来创建一个预期长度的数组（元素个数为`(end-start)/step`或者`(end+1-start)/step`）,使用`Array.prototype.map()`来用范围内期望的数填充它。`start`默认值为`0`，`step`默认值为`1`。\n"
  },
  "initializeArrayWithValues": {
    "prefix": "30s_initializeArrayWithValues",
    "body": [
      "const initializeArrayWithValues = (n, val = 0) => Array(n).fill(val);"
    ],
    "description": "Initializes and fills an array with the specified values.\n\n用给定的值初始化并填充一个数组。\n\nUse `Array(n)` to create an array of the desired length, `fill(v)` to fill it with the desired values.\nYou can omit `val` to use a default value of `0`.\n\n使用`Array(n)`来创建一个期望长度的数组，用`fill(v)`来给它填充期望的值。`val`不传，则使用默认值`0`。\n"
  },
  "initializeNDArray": {
    "prefix": "30s_initializeNDArray",
    "body": [
      "const initializeNDArray = (val, ...args) =>",
      "  args.length === 0",
      "    ? val",
      "    : Array.from({ length: args[0] }).map(() => initializeNDArray(val, ...args.slice(1)));"
    ],
    "description": "Create a n-dimensional array with given value.\n\n使用给定值创建一个n维数组。\n\nUse recursion.\nUse `Array.prototype.map()` to generate rows where each is a new array initialized using `initializeNDArray`.\n\n使用递归。使用`Array.prototype.map()`来生成由`initializeNDArray`初始化的每一行。\n"
  },
  "inRange": {
    "prefix": "30s_inRange",
    "body": [
      "const inRange = (n, start, end = null) => {",
      "  if (end && start > end) [end, start] = [start, end];",
      "  return end == null ? n >= 0 && n < start : n >= start && n < end;",
      "};"
    ],
    "description": "Checks if the given number falls within the given range.\n\n检查给定的数是否落在给定的范围内。\n\nUse arithmetic comparison to check if the given number is in the specified range.\nIf the second parameter, `end`, is not specified, the range is considered to be from `0` to `start`.\n\n使用算术比较符来检查给定的数是否在指定的范围中。如果第二个参数`end`不指定，这个范围则视为从`0`到`start`。\n"
  },
  "insertAfter": {
    "prefix": "30s_insertAfter",
    "body": [
      "const insertAfter = (el, htmlString) => el.insertAdjacentHTML('afterend', htmlString);"
    ],
    "description": "Inserts an HTML string after the end of the specified element.\n\n在指定元素的后面添加一个HTML字符串。\n\nUse `el.insertAdjacentHTML()` with a position of `'afterend'` to parse `htmlString` and insert it after the end of `el`.\n\n使用`el.insertAdjacentHTML()`，以`'afterend'`作为position来解析`htmlString`，并把它插入到`el`后面。\n"
  },
  "insertBefore": {
    "prefix": "30s_insertBefore",
    "body": [
      "const insertBefore = (el, htmlString) => el.insertAdjacentHTML('beforebegin', htmlString);"
    ],
    "description": "Inserts an HTML string before the start of the specified element.\n\n在指定元素的前面添加一个HTML字符串。\n\nUse `el.insertAdjacentHTML()` with a position of `'beforebegin'` to parse `htmlString` and insert it before the start of `el`.\n\n使用`el.insertAdjacentHTML()`，以`'beforebegin'`作为position来解析`htmlString`，并把它插入到`el`后面。"
  },
  "intersection": {
    "prefix": "30s_intersection",
    "body": [
      "const intersection = (a, b) => {",
      "  const s = new Set(b);",
      "  return a.filter(x => s.has(x));",
      "};"
    ],
    "description": "Returns a list of elements that exist in both arrays.\n\n返回两个数组公共元素组成的元素列表。\n\nCreate a `Set` from `b`, then use `Array.prototype.filter()` on `a` to only keep values contained in `b`.\n\n从`b`创建一个`Set`，然后使用`Array.prototype.filter()`来让`a`只保留存在`b`中的元素。\n"
  },
  "intersectionBy": {
    "prefix": "30s_intersectionBy",
    "body": [
      "const intersectionBy = (a, b, fn) => {",
      "  const s = new Set(b.map(fn));",
      "  return a.filter(x => s.has(fn(x)));",
      "};"
    ],
    "description": "Returns a list of elements that exist in both arrays, after applying the provided function to each array element of both.\n\n返回两个数组公共元素组成的元素列表，通过给定的函数`fn`来判断元素是否相同。\n\nCreate a `Set` by applying `fn` to all elements in `b`, then use `Array.prototype.filter()` on `a` to only keep elements, which produce values contained in `b` when `fn` is applied to them.\n\n对`b`中所有元素应用函数`fn`，用结果创建一个`Set`，然后使用`Array.prototype.filter()`来让`a`只保留`b`应用`fn`的结果中的元素。\n"
  },
  "intersectionWith": {
    "prefix": "30s_intersectionWith",
    "body": [
      "const intersectionWith = (a, b, comp) => a.filter(x => b.findIndex(y => comp(x, y)) !== -1);"
    ],
    "description": "Returns a list of elements that exist in both arrays, using a provided comparator function.\n\n返回两个数组公共元素组成的元素列表，通过给定的比较函数`comp`来判断元素是否相同。\n\nUse `Array.prototype.filter()` and `Array.prototype.findIndex()` in combination with the provided comparator to determine intersecting values.\n\n使用`Array.prototype.filter()` 和 `Array.prototype.findIndex()`，结合给定的比较函数判断是否公共值。\n"
  },
  "invertKeyValues": {
    "prefix": "30s_invertKeyValues",
    "body": [
      "const invertKeyValues = (obj, fn) =>",
      "  Object.keys(obj).reduce((acc, key) => {",
      "    const val = fn ? fn(obj[key]) : obj[key];",
      "    acc[val] = acc[val] || [];",
      "    acc[val].push(key);",
      "    return acc;",
      "  }, {});"
    ],
    "description": "Inverts the key-value pairs of an object, without mutating it. The corresponding inverted value of each inverted key is an array of keys responsible for generating the inverted value. If a function is supplied, it is applied to each inverted key.\n\n转化一个对象的键值对（不改变对象本身）。每个转化后的键的对应的转化后的值是一个与产生的转化后的值对应的键列表。如果提供了函数，它会被应用到每个转化后的值。\n\nUse `Object.keys()` and `Array.prototype.reduce()` to invert the key-value pairs of an object and apply the function provided (if any).\nOmit the second argument, `fn`, to get the inverted keys without applying a function to them.\n\n使用`Object.keys()`和`Array.prototype.reduce()`来转化一个对象的键值对，然后应用这个给出的函数（如果有的话）。如果不传第二个参数`fn`，则不对转化后的键应用函数。\n"
  },
  "is": {
    "prefix": "30s_is",
    "body": [
      "const is = (type, val) => ![, null].includes(val) && val.constructor === type;"
    ],
    "description": "Checks if the provided value is of the specified type.\n\n检查提供的值是不是特定的类型。\n\nEnsure the value is not `undefined` or `null` using `Array.prototype.includes()`, and compare the `constructor` property on the value with `type` to check if the provided value is of the specified `type`.\n\n使用`Array.prototype.includes()`确保这个值不是`undefined`或者`null`，然后比较值的`constructor`属性和`type`来检查提供的值是不是特定的类型。\n"
  },
  "isAbsoluteURL": {
    "prefix": "30s_isAbsoluteURL",
    "body": [
      "const isAbsoluteURL = str => /^[a-z][a-z0-9+.-]*:/.test(str);"
    ],
    "description": "Returns `true` if the given string is an absolute URL, `false` otherwise.\n\n如果给出的字符串是绝对路径的URL，则返回`true`，否则返回`false`。\n\nUse a regular expression to test if the string is an absolute URL.\n\n使用正则表达式来测试这个字符串是否为一个绝对路径的URL。\n"
  },
  "isAfterDate": {
    "prefix": "30s_isAfterDate",
    "body": [
      "const isAfterDate = (dateA, dateB) => dateA > dateB;"
    ],
    "description": "Check if a date is after another date.\n\n检查一个日期是否在另一个日期后面。\n\nUse the greater than operator (`>`) to check if the first date comes after the second one.\n\n使用大于比较操作符(`>`)来检查第一个日期是否在第二个后面。\n"
  },
  "isAnagram": {
    "prefix": "30s_isAnagram",
    "body": [
      "const isAnagram = (str1, str2) => {",
      "  const normalize = str =>",
      "    str",
      "      .toLowerCase()",
      "      .replace(/[^a-z0-9]/gi, '')",
      "      .split('')",
      "      .sort()",
      "      .join('');",
      "  return normalize(str1) === normalize(str2);",
      "};"
    ],
    "description": "Checks if a string is an anagram of another string (case-insensitive, ignores spaces, punctuation and special characters).\n\nUse `String.prototype.toLowerCase()`, `String.prototype.replace()` with an appropriate regular expression to remove unnecessary characters, `String.prototype.split('')`, `Array.prototype.sort()` and `Array.prototype.join('')` on both strings to normalize them, then check if their normalized forms are equal.\n"
  },
  "isArrayLike": {
    "prefix": "30s_isArrayLike",
    "body": [
      "const isArrayLike = obj => obj != null && typeof obj[Symbol.iterator] === 'function';"
    ],
    "description": "Checks if the provided argument is array-like (i.e. is iterable).\n\n检查给定的参数是否是类数组类型（例如iterable）。\n\nCheck if the provided argument is not `null` and that its `Symbol.iterator` property is a function.\n\n检查给定的参数是否不是`null`，并且它的`Symbol.iterator`属性是一个函数。\n"
  },
  "isBeforeDate": {
    "prefix": "30s_isBeforeDate",
    "body": [
      "const isBeforeDate = (dateA, dateB) => dateA < dateB;"
    ],
    "description": "Check if a date is before another date.\n\n检查一个日期是否在另一个日期前面。\n\nUse the less than operator (`<`) to check if the first date comes before the second one.\n\n使用小于比较操作符(`>`)来检查第一个日期是否在第二个前面。\n"
  },
  "isBoolean": {
    "prefix": "30s_isBoolean",
    "body": [
      "const isBoolean = val => typeof val === 'boolean';"
    ],
    "description": "Checks if the given argument is a native boolean element.\n\n检查给出的参数是否是一个原生boolean元素。\n\nUse `typeof` to check if a value is classified as a boolean primitive.\n\n使用`typeof`来检查一个值是否被分类为一个boolean原生类型。\n"
  },
  "isBrowser": {
    "prefix": "30s_isBrowser",
    "body": [
      "const isBrowser = () => ![typeof window, typeof document].includes('undefined');"
    ],
    "description": "Determines if the current runtime environment is a browser so that front-end modules can run on the server (Node) without throwing errors.\n\n判定当前的执行环境是否是浏览器，以判断是否前端的模块可以不报错的在server上运行（Node）。\n\nUse `Array.prototype.includes()` on the `typeof` values of both `window` and `document` (globals usually only available in a browser environment unless they were explicitly defined), which will return `true` if one of them is `undefined`.\n`typeof` allows globals to be checked for existence without throwing a `ReferenceError`.\nIf both of them are not `undefined`, then the current environment is assumed to be a browser.\n\n对`window`和`docoment`（通常除了显示定义，只在浏览器中才可用的全局变量）的`typeof`值使用`Array.prototype.includes()`，如果它们中有一个是`undefined`则返回`true`。`typeof`运行在不报`ReferenceError`错误的情况下检查全局变量的存在性。如果它们都不是`undefined`，则当前的环境被当做一个浏览器环境。\n"
  },
  "isBrowserTabFocused": {
    "prefix": "30s_isBrowserTabFocused",
    "body": [
      "const isBrowserTabFocused = () => !document.hidden;"
    ],
    "description": "Returns `true` if the browser tab of the page is focused, `false` otherwise.\n\n如果当前的浏览器标签页是获取到焦点的就返回`true`，否则返回`false`。\n\nUse the `Document.hidden` property, introduced by the Page Visibility API to check if the browser tab of the page is visible or hidden.\n\n使用页面可见性API（Page Visibility API）中的`Document.hidden`属性来检查当前的浏览器标签页是可见的还是隐藏的。\n"
  },
  "isContainedIn": {
    "prefix": "30s_isContainedIn",
    "body": [
      "const isContainedIn = (a, b) => {",
      "  for (const v of new Set(a)) {",
      "    if (!b.some(e => e === v) || a.filter(e => e === v).length > b.filter(e => e === v).length)",
      "      return false;",
      "  }",
      "  return true;",
      "};"
    ],
    "description": "Returns `true` if the elements of the first array are contained in the second one regardless of order, `false` otherwise.\n\nUse a `for...of` loop over a `Set` created from the first array.\nUse `Array.prototype.some()` to check if all distinct values are contained in the second array, use `Array.prototype.filter()` to compare the number of occurrences of each distinct value in both arrays.\nReturn `false` if the count of any element is greater in the first array than the second one, `true` otherwise.\n"
  },
  "isDivisible": {
    "prefix": "30s_isDivisible",
    "body": [
      "const isDivisible = (dividend, divisor) => dividend % divisor === 0;"
    ],
    "description": "Checks if the first numeric argument is divisible by the second one.\n\n检查第一个数字参数是否能被第二个整除。\n\nUse the modulo operator (`%`) to check if the remainder is equal to `0`.\n\n使用取余操作符(`%`)检查余数是否为`0`。\n"
  },
  "isDuplexStream": {
    "prefix": "30s_isDuplexStream",
    "body": [
      "const isDuplexStream = val =>",
      "  val !== null &&",
      "  typeof val === 'object' &&",
      "  typeof val.pipe === 'function' &&",
      "  typeof val._read === 'function' &&",
      "  typeof val._readableState === 'object' &&",
      "  typeof val._write === 'function' &&",
      "  typeof val._writableState === 'object';"
    ],
    "description": "Checks if the given argument is a duplex (readable and writable) stream.\n\n检查给出的参数是否是双向的（可读可写的）流。\n\nCheck if the value is different from `null`, use `typeof` to check if a value is of type `object` and the `pipe` property is of type `function`.\nAdditionally check if the `typeof` the `_read`, `_write` and `_readableState`, `_writableState` properties are `function` and `object` respectively.\n\n检查给出的值是否不是`null`，使用`typeof`来检查这个值是否是`object`类型，它的`pipe`属性是否是一个`function`类型。再检查它的`_read`、`_write`和`_readableState`, `_writableState`属性的`typeof`是否分别是`function`和`object`类型。\n"
  },
  "isEmpty": {
    "prefix": "30s_isEmpty",
    "body": [
      "const isEmpty = val => val == null || !(Object.keys(val) || val).length;"
    ],
    "description": "Returns true if the a value is an empty object, collection, has no enumerable properties or is any type that is not considered a collection.\n\n如果一个值是一个空对象、集合、映射或者非重复集合，或者没有可枚举属性，或者是任何一种不被当做集合的类型，则返回真。\n\nCheck if the provided value is `null` or if its `length` is equal to `0`.\n\n检查给出的值是否是`null`或者是否它的`length`属性等于`0`。\n"
  },
  "isEven": {
    "prefix": "30s_isEven",
    "body": [
      "const isEven = num => num % 2 === 0;"
    ],
    "description": "Returns `true` if the given number is even, `false` otherwise.\n\n如果给出的数字是偶数则返回`true`，否则返回`false`。\n\nChecks whether a number is odd or even using the modulo (`%`) operator.\nReturns `true` if the number is even, `false` if the number is odd.\n\n使用取余操作符(`%`)检查一个数字是奇数还是偶数。如果给出的数字是偶数则返回`true`，否则返回`false`。\n"
  },
  "isFunction": {
    "prefix": "30s_isFunction",
    "body": [
      "const isFunction = val => typeof val === 'function';"
    ],
    "description": "Checks if the given argument is a function.\n\n检查给出的参数是否是一个函数。\n\nUse `typeof` to check if a value is classified as a function primitive.\n\n使用`typeof`来检查一个值是否被分类为一个原生的函数类型。\n"
  },
  "isLowerCase": {
    "prefix": "30s_isLowerCase",
    "body": [
      "const isLowerCase = str => str === str.toLowerCase();"
    ],
    "description": "Checks if a string is lower case.\n\n检测一个字符串是否为小写格式。\n\nConvert the given string to lower case, using `String.toLowerCase()` and compare it to the original.\n\n使用`String.toLowerCase()`把给定的字符串转换为小写格式，并把它和原始字符串比较。\n"
  },
  "isNegativeZero": {
    "prefix": "30s_isNegativeZero",
    "body": [
      "const isNegativeZero = val => val === 0 && 1 / val === -Infinity;"
    ],
    "description": "Checks if the given value is equal to negative zero (`-0`).\n\n检查给出的值是否与负数0相等(`-0`)。\n\nChecks whether a passed value is equal to `0` and if `1` divided by the value equals `-Infinity`.\n\n检查传入的是否等于`0`，并且`1`被这个值除是否等于`-Infinity`。\n"
  },
  "isNil": {
    "prefix": "30s_isNil",
    "body": [
      "const isNil = val => val === undefined || val === null;"
    ],
    "description": "Returns `true` if the specified value is `null` or `undefined`, `false` otherwise.\n\n如果指定的值是`null`或者`undefined`则返回`true`，否则返回`false`。\n\nUse the strict equality operator to check if the value and of `val` are equal to `null` or `undefined`.\n\n使用严格相等操作符来检查`val`的值是否等于`null`或者`undefined`。\n"
  },
  "isNull": {
    "prefix": "30s_isNull",
    "body": [
      "const isNull = val => val === null;"
    ],
    "description": "Returns `true` if the specified value is `null`, `false` otherwise.\n\n如果指定的值是`null`则返回`true`，否则返回`false`。\n\nUse the strict equality operator to check if the value and of `val` are equal to `null`.\n\n使用严格相等操作符来检查`val`的值是否等于`null`。\n"
  },
  "isNumber": {
    "prefix": "30s_isNumber",
    "body": [
      "const isNumber = val => typeof val === 'number' && val === val;"
    ],
    "description": "Checks if the given argument is a number.\n\n检查给出的参数是否是一个数字。\n\nUse `typeof` to check if a value is classified as a number primitive. \nTo safeguard against `NaN`, check if `val === val` (as `NaN` has a `typeof` equal to `number` and is the only value not equal to itself).\n\n使用`typeof`来检查一个值是否被分类为一个原生数字类型。为了确保关于`NaN`的类型安全，检查`val === val`（因为`NaN`的`typeof`也是`number`，但它的值不等于它本身）（检查`NaN`的常见方法）\n"
  },
  "isObject": {
    "prefix": "30s_isObject",
    "body": [
      "const isObject = obj => obj === Object(obj);"
    ],
    "description": "Returns a boolean determining if the passed value is an object or not.\n\n返回一个布尔判定，判定传入的值是一个对象或者不是。\n\nUses the  `Object` constructor to create an object wrapper for the given value. \nIf the value is `null` or `undefined`, create and return an empty object. Οtherwise, return an object of a type that corresponds to the given value.\n\n使用`Object`构造函数来创建一个给出值的对象包裹。如果这个值是`null`或`undefined`，创建并返回一个空对象。否则返回一个与给出值相应类型的对象。\n"
  },
  "isObjectLike": {
    "prefix": "30s_isObjectLike",
    "body": [
      "const isObjectLike = val => val !== null && typeof val === 'object';"
    ],
    "description": "Checks if a value is object-like.\n\n检查一个值是否是对象类似类型。\n\nCheck if the provided value is not `null` and its `typeof` is equal to `'object'`.\n\n检查给出的值是否不是`null`，它的`typeof`是否等于`'object'`。\n"
  },
  "isOdd": {
    "prefix": "30s_isOdd",
    "body": [
      "const isOdd = num => num % 2 === 1;"
    ],
    "description": "Returns `true` if the given number is odd, `false` otherwise.\n\nChecks whether a number is odd or even using the modulo (`%`) operator.\nReturns `true` if the number is odd, `false` if the number is even.\n"
  },
  "isPlainObject": {
    "prefix": "30s_isPlainObject",
    "body": [
      "const isPlainObject = val => !!val && typeof val === 'object' && val.constructor === Object;"
    ],
    "description": "Checks if the provided value is an object created by the Object constructor.\n\n检查给出的值是否是一个对象构造器创建的对象。\n\nCheck if the provided value is truthy, use `typeof` to check if it is an object and `Object.constructor` to make sure the constructor is equal to `Object`.\n\n检查给出的值是否为真值，使用`typeof`来检查它是否是一个对象，使用`Object.constructor`来确保它的构造器等于`Object`。\n"
  },
  "isPowerOfTwo": {
    "prefix": "30s_isPowerOfTwo",
    "body": [
      "const isPowerOfTwo = n => !!n && (n & (n - 1)) == 0;"
    ],
    "description": "Returns `true` if the given number is a power of `2`, `false` otherwise.\n\nUse the bitwise binary AND operator (`&`) to determine if `n is a power of `2. \nAdditionally, check that `n` is not falsy.\n"
  },
  "isPrime": {
    "prefix": "30s_isPrime",
    "body": [
      "const isPrime = num => {",
      "  const boundary = Math.floor(Math.sqrt(num));",
      "  for (var i = 2; i <= boundary; i++) if (num % i === 0) return false;",
      "  return num >= 2;",
      "};"
    ],
    "description": "Checks if the provided integer is a prime number.\n\n检查给出的整数是否为质数。\n\nCheck numbers from `2` to the square root of the given number.\nReturn `false` if any of them divides the given number, else return `true`, unless the number is less than `2`.\n\n检查从`2`到给出数字的平方根范围内的数字。如果给出的数被其中任意一个整除，则返回`false`，否则返回`true`，除非这个数小于`2`。\n"
  },
  "isPrimitive": {
    "prefix": "30s_isPrimitive",
    "body": [
      "const isPrimitive = val => Object(val) !== val;"
    ],
    "description": "Returns a boolean determining if the passed value is primitive or not.\n\n返回一个布尔判定， 它判定传入的值是否是原始的类型。\n\nCreate an object from `val` and compare it with `val` to determine if the passed value is primitive (i.e. not equal to the created object).\n\n从`val`创建一个对象，把它和`val`本身比较来判定传入的值是否是原始的类型（例如：不等于创建的对象）。\n"
  },
  "isPromiseLike": {
    "prefix": "30s_isPromiseLike",
    "body": [
      "const isPromiseLike = obj =>",
      "  obj !== null &&",
      "  (typeof obj === 'object' || typeof obj === 'function') &&",
      "  typeof obj.then === 'function';"
    ],
    "description": "Returns `true` if an object looks like a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), `false` otherwise.\n\n如果一个对象类似一个[`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)则返回`true`，否则返回`false`。\n\nCheck if the object is not `null`, its `typeof` matches either `object` or `function` and if it has a `.then` property, which is also a `function`.\n\n检查这个对象是否不是`null`，它的`typeof`是否匹配`object`或者`function`，并且是否有一个`function`类型的`.then`属性。\n"
  },
  "isReadableStream": {
    "prefix": "30s_isReadableStream",
    "body": [
      "const isReadableStream = val =>",
      "  val !== null &&",
      "  typeof val === 'object' &&",
      "  typeof val.pipe === 'function' &&",
      "  typeof val._read === 'function' &&",
      "  typeof val._readableState === 'object';"
    ],
    "description": "Checks if the given argument is a readable stream.\n\n检测给出的参数是否是可写的流。\n\nCheck if the value is different from `null`, use `typeof` to check if the value is of type `object` and the `pipe` property is of type `function`.\nAdditionally check if the `typeof` the `_read` and `_readableState` properties are `function` and `object` respectively.\n\n检查给出的值是否不是`null`，使用`typeof`来检查这个值是否是`object`类型，它的`pipe`属性是否是一个`function`类型。再检查它的`_read`、和`_readableState`属性的`typeof`是否分别是`function`和`object`类型。\n"
  },
  "isSameDate": {
    "prefix": "30s_isSameDate",
    "body": [
      "const isSameDate = (dateA, dateB) => dateA.toISOString() === dateB.toISOString();"
    ],
    "description": "Check if a date is the same as another date.\n\n检查一个日期是否与另一个日期相同。\n\nUse `Date.prototype.toISOString()` and strict equality checking (`===`) to check if the first date is the same as the second one.\n\n使用`Date.prototype.toISOString()`和严格的相等符号(`===`) 来检查第一个日期是否与第二个相同。\n"
  },
  "isSorted": {
    "prefix": "30s_isSorted",
    "body": [
      "const isSorted = arr => {",
      "  let direction = -(arr[0] - arr[1]);",
      "  for (let [i, val] of arr.entries()) {",
      "    direction = !direction ? -(arr[i - 1] - arr[i]) : direction;",
      "    if (i === arr.length - 1) return !direction ? 0 : direction;",
      "    else if ((val - arr[i + 1]) * direction > 0) return 0;",
      "  }",
      "};"
    ],
    "description": "Returns `1` if the array is sorted in ascending order, `-1` if it is sorted in descending order or `0` if it is not sorted.\n\n如果数组正序，返回`1`；如果倒序，返回`-1`；如果没有排序，则返回`0`。\n\nCalculate the ordering `direction` for the first two elements.\nUse `Object.entries()` to loop over array objects and compare them in pairs.\nReturn `0` if the `direction` changes or the `direction` if the last element is reached.\n\n通过前两个元素计算出顺序`direction`。使用`Object.entries()`来遍历数组对象，相邻元素成对比较顺序。如果`direction`变化了，整体返回`0`；否则遍历完最后一个元素后整体把`direction`返回作为结果。\n"
  },
  "isStream": {
    "prefix": "30s_isStream",
    "body": [
      "const isStream = val => val !== null && typeof val === 'object' && typeof val.pipe === 'function';"
    ],
    "description": "Checks if the given argument is a stream.\n\n检测给出的参数是否是一个流。\n\nCheck if the value is different from `null`, use `typeof` to check if the value is of type `object` and the `pipe` property is of type `function`.\n\n检查给出的值是否不是`null`，使用`typeof`来检查这个值是否是`object`类型，它的`pipe`属性是否是一个`function`类型。\n"
  },
  "isString": {
    "prefix": "30s_isString",
    "body": [
      "const isString = val => typeof val === 'string';"
    ],
    "description": "Checks if the given argument is a string. Only works for string primitives.\n\n检查给出的参数是否是一个字符串，只对原始的字符串类型生效。\n\nUse `typeof` to check if a value is classified as a string primitive.\n\n使用`typeof`来检查一个值是否被分类为一个原始的字符串类型。\n"
  },
  "isSymbol": {
    "prefix": "30s_isSymbol",
    "body": [
      "const isSymbol = val => typeof val === 'symbol';"
    ],
    "description": "Checks if the given argument is a symbol.\n\n检查给出的值是否是一个symbol类型。\n\nUse `typeof` to check if a value is classified as a symbol primitive.\n\n使用`typeof`来检查一个值是否被分类为一个原始的symbol类型。\n"
  },
  "isTravisCI": {
    "prefix": "30s_isTravisCI",
    "body": [
      "const isTravisCI = () => 'TRAVIS' in process.env && 'CI' in process.env;"
    ],
    "description": "Checks if the current environment is [Travis CI](https://travis-ci.org/).\n\n检测当前环境是不是[Travis CI](https://travis-ci.org/)的环境。\n\nChecks if the current environment has the `TRAVIS` and `CI` environment variables ([reference](https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables)).\n\n检测当前环境是否有`TRAVIS`和`CI`环境变量([reference](https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables))。\n"
  },
  "isUndefined": {
    "prefix": "30s_isUndefined",
    "body": [
      "const isUndefined = val => val === undefined;"
    ],
    "description": "Returns `true` if the specified value is `undefined`, `false` otherwise.\n\n如果指定的值是`undefined`则返回`true`，否则返回`false`。\n\nUse the strict equality operator to check if the value and of `val` are equal to `undefined`.\n\n使用严格相等操作符来检查`val`的值是否等于`undefined`。\n"
  },
  "isUpperCase": {
    "prefix": "30s_isUpperCase",
    "body": [
      "const isUpperCase = str => str === str.toUpperCase();"
    ],
    "description": "Checks if a string is upper case.\n\n检测一个字符串是否为大写格式。\n\nConvert the given string to upper case, using `String.prototype.toUpperCase()` and compare it to the original.\n\n使用`String.toLowerCase()`把给定的字符串转换为大写格式，并把它和原始字符串比较。\n"
  },
  "isValidJSON": {
    "prefix": "30s_isValidJSON",
    "body": [
      "const isValidJSON = str => {",
      "  try {",
      "    JSON.parse(str);",
      "    return true;",
      "  } catch (e) {",
      "    return false;",
      "  }",
      "};"
    ],
    "description": "Checks if the provided string is a valid JSON.\n\n检查给出的字符串是否是一个合法的JSON。\n\nUse `JSON.parse()` and a `try... catch` block to check if the provided string is a valid JSON.\n\n使用`JSON.parse()`和一个`try... catch`代码块来检查给出的字符串是否是一个合法的JSON。\n"
  },
  "isWeekday": {
    "prefix": "30s_isWeekday",
    "body": [
      "const isWeekday = (t = new Date()) => {",
      "  return t.getDay() % 6 !== 0;",
      "};"
    ],
    "description": "Results in a boolean representation of a specific date.\n\nPass the specific date object firstly.\nUse `Date.getDay()` to check weekday by using a modulo operator and then returning a boolean.\n"
  },
  "isWeekend": {
    "prefix": "30s_isWeekend",
    "body": [
      "const isWeekend = (t = new Date()) => {",
      "  return t.getDay() % 6 === 0;",
      "};"
    ],
    "description": "Results in a boolean representation of a specific date.\n\nPass the specific date object firstly.\nUse `Date.getDay()` to check weekend based on the day being returned as 0 - 6 using a modulo operation then return a boolean.\n"
  },
  "isWritableStream": {
    "prefix": "30s_isWritableStream",
    "body": [
      "const isWritableStream = val =>",
      "  val !== null &&",
      "  typeof val === 'object' &&",
      "  typeof val.pipe === 'function' &&",
      "  typeof val._write === 'function' &&",
      "  typeof val._writableState === 'object';"
    ],
    "description": "Checks if the given argument is a writable stream.\n\n检测给出的参数是否是可读的流。\n\nCheck if the value is different from `null`, use `typeof` to check if the value is of type `object` and the `pipe` property is of type `function`.\nAdditionally check if the `typeof` the `_write` and `_writableState` properties are `function` and `object` respectively.\n\n检查给出的值是否不是`null`，使用`typeof`来检查这个值是否是`object`类型，它的`pipe`属性是否是一个`function`类型。再检查它的`_write`、和`_writableState`属性的`typeof`是否分别是`function`和`object`类型。\n"
  },
  "join": {
    "prefix": "30s_join",
    "body": [
      "const join = (arr, separator = ',', end = separator) =>",
      "  arr.reduce(",
      "    (acc, val, i) =>",
      "      i === arr.length - 2",
      "        ? acc + val + end",
      "        : i === arr.length - 1",
      "        ? acc + val",
      "        : acc + val + separator,",
      "    ''",
      "  );"
    ],
    "description": "Joins all elements of an array into a string and returns this string.\nUses a separator and an end separator.\n\n把数组中的所有元素连结成一个字符串并返回。可以指定分隔符`separator`和结束符号`end`。\n\nUse `Array.prototype.reduce()` to combine elements into a string.\nOmit the second argument, `separator`, to use a default separator of `','`.\nOmit the third argument, `end`, to use the same value as `separator` by default.\n\n使用 `Array.prototype.reduce()`把元素列表结合成一个字符串。如果不传第二个参数`separator`，默认值为`','`；如果不传第三个参数`end`，默认值为`separator`的值。\n"
  },
  "JSONtoCSV": {
    "prefix": "30s_JSONtoCSV",
    "body": [
      "const JSONtoCSV = (arr, columns, delimiter = ',') =>",
      "  [",
      "    columns.join(delimiter),",
      "    ...arr.map(obj =>",
      "      columns.reduce(",
      "        (acc, key) => `${acc}${!acc.length ? '' : delimiter}\"${!obj[key] ? '' : obj[key]}\"`,",
      "        ''",
      "      )",
      "    )",
      "  ].join('\\n');"
    ],
    "description": "Converts an array of objects to a comma-separated values (CSV) string that contains only the `columns` specified.\n\n把一个对象数组转换为只包含`columns`中的列（对应objects中的属性名）的点分(CSV)字符串。\n\nUse `Array.prototype.join(delimiter)` to combine all the names in `columns` to create the first row.\nUse `Array.prototype.map()` and `Array.prototype.reduce()` to create a row for each object, substituting non-existent values with empty strings and only mapping values in `columns`.\nUse `Array.prototype.join('\\n')` to combine all rows into a string.\nOmit the third argument, `delimiter`, to use a default delimiter of `,`.\n\n使用`Array.prototype.join(delimiter)`来连结`columns`中所有属性名来创建第一行。使用`Array.prototype.map()`和`Array.prototype.reduce()`来为每个对象创建一行，不存在的值使用空字符串替代。使用`Array.prototype.join('\\n')`来把所有上面的行连结成字符串。如果不传第三个参数`delimiter`，默认值为`,`。\n"
  },
  "JSONToFile": {
    "prefix": "30s_JSONToFile",
    "body": [
      "const fs = require('fs');",
      "const JSONToFile = (obj, filename) =>",
      "  fs.writeFile(`${filename}.json`, JSON.stringify(obj, null, 2));"
    ],
    "description": "Writes a JSON object to a file.\n\n把一个JSON对象写到文件中。\n\nUse `fs.writeFile()`, template literals and `JSON.stringify()` to write a `json` object to a `.json` file.\n\n使用`fs.writeFile()`、模板字面量和`JSON.stringify()`来把这个`json`对象写到一个`.json`文件中。\n"
  },
  "last": {
    "prefix": "30s_last",
    "body": [
      "const last = arr => (arr && arr.length ? arr[arr.length - 1] : undefined);"
    ],
    "description": "Returns the last element in an array.\n\nCheck if `arr` is truthy and has a `length` property, use `arr.length - 1` to compute the index of the last element of the given array and return it, otherwise return `undefined`.\n"
  },
  "lcm": {
    "prefix": "30s_lcm",
    "body": [
      "const lcm = (...arr) => {",
      "  const gcd = (x, y) => (!y ? x : gcd(y, x % y));",
      "  const _lcm = (x, y) => (x * y) / gcd(x, y);",
      "  return [...arr].reduce((a, b) => _lcm(a, b));",
      "};"
    ],
    "description": "Returns the least common multiple of two or more numbers.\n\n返回两个或多个数字的最小公倍数。\n\nUse the greatest common divisor (GCD) formula and the fact that `lcm(x,y) = x * y / gcd(x,y)` to determine the least common multiple.\nThe GCD formula uses recursion.\n\n使用最大公因数（GCD）和因子`lcm(x,y) = x * y / gcd(x,y)`来判断最小公倍数。GCD的公式使用递归。\n"
  },
  "longestItem": {
    "prefix": "30s_longestItem",
    "body": [
      "const longestItem = (...vals) => vals.reduce((a, x) => (x.length > a.length ? x : a));"
    ],
    "description": "Takes any number of iterable objects or objects with a `length` property and returns the longest one.\nIf multiple objects have the same length, the first one will be returned.\nReturns `undefined` if no arguments are provided.\n\n接收任意数量的可迭代对象（或有`length`属性的对象）并返回最长的一个。如果其中多个对象有相同的长度，将返回第一个。如果没有传入参数，返回`undefined`。\n\nUse `Array.prototype.reduce()`, comparing the `length` of objects to find the longest one.\n\n使用`Array.prototype.reduce()`来比较项目的`length`来找到最长的一个。\n"
  },
  "lowercaseKeys": {
    "prefix": "30s_lowercaseKeys",
    "body": [
      "const lowercaseKeys = obj =>",
      "  Object.keys(obj).reduce((acc, key) => {",
      "    acc[key.toLowerCase()] = obj[key];",
      "    return acc;",
      "  }, {});"
    ],
    "description": "Creates a new object from the specified object, where all the keys are in lowercase.\n\n从指定的对象中创建一个新的每个键都是小写形式的对象。\n\nUse `Object.keys()` and `Array.prototype.reduce()` to create a new object from the specified object.\nConvert each key in the original object to lowercase, using `String.toLowerCase()`.\n\n使用`Object.keys()`和`Array.prototype.reduce()`来从指定的对象中创建一个新的对象。使用`String.toLowerCase()`把原始对象中每个键都转到小写形式。\n"
  },
  "luhnCheck": {
    "prefix": "30s_luhnCheck",
    "body": [
      "const luhnCheck = num => {",
      "  let arr = (num + '')",
      "    .split('')",
      "    .reverse()",
      "    .map(x => parseInt(x));",
      "  let lastDigit = arr.splice(0, 1)[0];",
      "  let sum = arr.reduce((acc, val, i) => (i % 2 !== 0 ? acc + val : acc + ((val * 2) % 9) || 9), 0);",
      "  sum += lastDigit;",
      "  return sum % 10 === 0;",
      "};"
    ],
    "description": "Implementation of the [Luhn Algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers etc.\n\n[Luhn Algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm)的实现，用来验证一个id的合法性，例如信用卡号，IMEI号，国家身份证号。\n\nUse `String.prototype.split('')`, `Array.prototype.reverse()` and `Array.prototype.map()` in combination with `parseInt()` to obtain an array of digits.\nUse `Array.prototype.splice(0,1)` to obtain the last digit.\nUse `Array.prototype.reduce()` to implement the Luhn Algorithm.\nReturn `true` if `sum` is divisible by `10`, `false` otherwise.\n\n使用`String.prototype.split('')`, `Array.prototype.reverse()`和`Array.prototype.map()`结合`parseInt()`来获取一个十进制数的数组。使用`Array.prototype.splice(0,1)`来获取十进制数的最后一位。使用`Array.prototype.reduce()`来实行Luhn算法。如果`sum`可以被`10`整除则返回`true`，否则返回`false`。\n"
  },
  "mapKeys": {
    "prefix": "30s_mapKeys",
    "body": [
      "const mapKeys = (obj, fn) =>",
      "  Object.keys(obj).reduce((acc, k) => {",
      "    acc[fn(obj[k], k, obj)] = obj[k];",
      "    return acc;",
      "  }, {});"
    ],
    "description": "Creates an object with keys generated by running the provided function for each key and the same values as the provided object.\n\n创建一个对象，它的键是通过对每个键和与给定对象中对应的值应用指定的函数来产生的。\n\nUse `Object.keys(obj)` to iterate over the object's keys.\nUse `Array.prototype.reduce()` to create a new object with the same values and mapped keys using `fn`.\n\n使用`Object.keys(obj)`来遍历对象的键列表。使用`Array.prototype.reduce()`来用对应的值和使用`fn`映射出的键列表创建一个新对象。\n"
  },
  "mapNumRange": {
    "prefix": "30s_mapNumRange",
    "body": [
      "const mapNumRange = (num, inMin, inMax, outMin, outMax) =>",
      "  ((num - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;"
    ],
    "description": "Maps a number from one range to another range.\n\n把一个数字从一个范围映射到另一个范围。\n\nReturns `num` mapped between `outMin`-`outMax` from `inMin`-`inMax`.\n\n返回从`inMin`-`inMax`范围映射到`outMin`-`outMax`范围的数字`num`。\n"
  },
  "mapObject": {
    "prefix": "30s_mapObject",
    "body": [
      "const mapObject = (arr, fn) =>",
      "  (a => (",
      "    (a = [arr, arr.map(fn)]), a[0].reduce((acc, val, ind) => ((acc[val] = a[1][ind]), acc), {})",
      "  ))();"
    ],
    "description": "Maps the values of an array to an object using a function, where the key-value pairs consist of the stringified value as the key and the mapped value.\n\n应用一个函数把数组中的值映射到一个以原始值作为key、函数结果作为value的key-value对象中。\n\nUse an anonymous inner function scope to declare an undefined memory space, using closures to store a return value. Use a new `Array` to store the array with a map of the function over its data set and a comma operator to return a second step, without needing to move from one context to another (due to closures and order of operations).\n\n使用一个匿名的内部函数作用域来声明一个未定义的内存空间，使用闭包来保存返回值。使用一个新的`Array`来存储函数作用数组后的结果，使用了逗号分隔符在不变更context（上下文）的情况下把第二步的操作结果返回（取决于闭包和操作符的顺序）。\n"
  },
  "mapString": {
    "prefix": "30s_mapString",
    "body": [
      "const mapString = (str, fn) =>",
      "  str",
      "    .split('')",
      "    .map((c, i) => fn(c, i, str))",
      "    .join('');"
    ],
    "description": "Creates a new string with the results of calling a provided function on every character in the calling string.\n\n创建一个由给出的字符串中每个字符上都应用给定的函数后产生的结果组成的字符串。\n\nUse `String.prototype.split('')` and `Array.prototype.map()` to call the provided function, `fn`, for each character in `str`.\nUse `Array.prototype.join('')` to recombine the array of characters into a string.\nThe callback function, `fn`, takes three arguments (the current character, the index of the current character and the string `mapString` was called upon).\n\n使用`String.prototype.split('')`和`Array.prototype.map()`来对`str`中的每个字符调用给定的函数`fn`。使用`Array.prototype.join('')`来把产生的字符数组重新组合为字符串。回调函数`fn`接受三个参数（当前字符，当前字符的序号，`mapString`所作用的字符串）。\n"
  },
  "mapValues": {
    "prefix": "30s_mapValues",
    "body": [
      "const mapValues = (obj, fn) =>",
      "  Object.keys(obj).reduce((acc, k) => {",
      "    acc[k] = fn(obj[k], k, obj);",
      "    return acc;",
      "  }, {});"
    ],
    "description": "Creates an object with the same keys as the provided object and values generated by running the provided function for each value.\n\n创建一个与给出的对象有相同键的一个对象，它的每个值都是用给出的函数处理后的结果。\n\nUse `Object.keys(obj)` to iterate over the object's keys.\nUse `Array.prototype.reduce()` to create a new object with the same keys and mapped values using `fn`.\n\n使用`Object.keys(obj)`来遍历对象的键列表。使用`Array.prototype.reduce()`来创建一个拥有相同键和用`fn`映射后的值的新对象。\n"
  },
  "mask": {
    "prefix": "30s_mask",
    "body": [
      "const mask = (cc, num = 4, mask = '*') => `${cc}`.slice(-num).padStart(`${cc}`.length, mask);"
    ],
    "description": "Replaces all but the last `num` of characters with the specified mask character.\n\n用指定的掩盖字符替换除了最后`num`个字符（只保留最后`num`个，其他字符替换为掩盖字符）。\n\nUse `String.prototype.slice()` to grab the portion of the characters that will remain unmasked and use `String.padStart()` to fill the beginning of the string with the mask character up to the original length.\nOmit the second argument, `num`, to keep a default of `4` characters unmasked. If `num` is negative, the unmasked characters will be at the start of the string.\nOmit the third argument, `mask`, to use a default character of `'*'` for the mask.\n\n使用`String.prototype.slice()`获取将要保留为不掩盖的字符串部分，并使用`String.padStart()`来用掩盖字符填充字符串的头部，直到填充为原始长度。\n如果不传第二个参数`num`，则默认保留`4`个字符不掩盖。如果`num`是负数，不掩盖的字符将会在字符串的头部。如果不传第三个参数`mask`，默认使用`'*'`作为掩盖字符。\n"
  },
  "matches": {
    "prefix": "30s_matches",
    "body": [
      "const matches = (obj, source) =>",
      "  Object.keys(source).every(key => obj.hasOwnProperty(key) && obj[key] === source[key]);"
    ],
    "description": "Compares two objects to determine if the first one contains equivalent property values to the second one.\n\n比较两个对象，确定第一个对象是否包含与第二个对象相同的属性值。\n\nUse `Object.keys(source)` to get all the keys of the second object, then `Array.prototype.every()`, `Object.hasOwnProperty()` and strict comparison to determine if all keys exist in the first object and have the same values.\n\n使用`Object.keys(source)`来获取第二个对象的键列表，然后用`Array.prototype.every()`, `Object.hasOwnProperty()`和严格等式来确定第一个对象中是否有相同的键，并且对应的键有相同的值。\n"
  },
  "matchesWith": {
    "prefix": "30s_matchesWith",
    "body": [
      "const matchesWith = (obj, source, fn) =>",
      "  Object.keys(source).every(key =>",
      "    obj.hasOwnProperty(key) && fn",
      "      ? fn(obj[key], source[key], key, obj, source)",
      "      : obj[key] == source[key]",
      "  );"
    ],
    "description": "Compares two objects to determine if the first one contains equivalent property values to the second one, based on a provided function.\n\n基于给出的函数，比较两个对象，确定第一个对象是否包含与第二个对象相同的属性值。\n\nUse `Object.keys(source)` to get all the keys of the second object, then `Array.prototype.every()`, `Object.hasOwnProperty()` and the provided function to determine if all keys exist in the first object and have equivalent values.\nIf no function is provided, the values will be compared using the equality operator.\n\n使用`Object.keys(source)`来获取第二个对象的键列表，然后用`Array.prototype.every()`, `Object.hasOwnProperty()`和给出的函数来确定第一个对象中是否有相同的键，并且对应的键有相同的值。如果没有`fn`函数参数，值将用等号操作符比较。\n"
  },
  "maxBy": {
    "prefix": "30s_maxBy",
    "body": [
      "const maxBy = (arr, fn) => Math.max(...arr.map(typeof fn === 'function' ? fn : val => val[fn]));"
    ],
    "description": "Returns the maximum value of an array, after mapping each element to a value using the provided function.\n\n在给数组中每个元素应用指定的函数后，返回一个其中的最大值。\n\nUse `Array.prototype.map()` to map each element to the value returned by `fn`, `Math.max()` to get the maximum value.\n\n使用`Array.prototype.map()`把每个元素映射到`fn`返回值，使用`Math.max()`来获取最大值。\n"
  },
  "maxDate": {
    "prefix": "30s_maxDate",
    "body": [
      "const maxDate = dates => new Date(Math.max(...dates));"
    ],
    "description": "Returns the maximum of the given dates.\n\nUse the ES6 spread syntax with `Math.max` to find the maximum date value, `new Date()` to convert it to a `Date` object.\n\n使用ES6的展开操作符配合`Math.max`来找到最大的日期值，用`new Date()`把它们转为一个`Date`对象。\n"
  },
  "maxN": {
    "prefix": "30s_maxN",
    "body": [
      "const maxN = (arr, n = 1) => [...arr].sort((a, b) => b - a).slice(0, n);"
    ],
    "description": "Returns the `n` maximum elements from the provided array.\nIf `n` is greater than or equal to the provided array's length, then return the original array (sorted in descending order).\n\n返回给定数组中最大的`n`个数。如果`n`大于等于给定数组的长度，则返回原始数组（倒序排列）。\n\nUse `Array.prototype.sort()` combined with the spread operator (`...`) to create a shallow clone of the array and sort it in descending order.\nUse `Array.prototype.slice()` to get the specified number of elements.\nOmit the second argument, `n`, to get a one-element array.\n\n使用`Array.prototype.sort()`结合展开操作符(`...`)来创建一个给定数组的浅拷贝，然后对它倒序排列。使用`Array.prototype.slice()`来获取元素列表中指定数目的元素。如果不传第二个参数`n`，则只获取一个元素。\n"
  },
  "median": {
    "prefix": "30s_median",
    "body": [
      "const median = arr => {",
      "  const mid = Math.floor(arr.length / 2),",
      "    nums = [...arr].sort((a, b) => a - b);",
      "  return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;",
      "};"
    ],
    "description": "Returns the median of an array of numbers.\n\n返回一个数字数组的中位数。\n\nFind the middle of the array, use `Array.prototype.sort()` to sort the values.\nReturn the number at the midpoint if `length` is odd, otherwise the average of the two middle numbers.\n\n使用`Array.prototype.sort()`排序数值后，找到数组的中间值。如果数组`length`是奇数，则返回最中间的数字，否则返回中间两个数字的平均值。\n"
  },
  "memoize": {
    "prefix": "30s_memoize",
    "body": [
      "const memoize = fn => {",
      "  const cache = new Map();",
      "  const cached = function(val) {",
      "    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);",
      "  };",
      "  cached.cache = cache;",
      "  return cached;",
      "};"
    ],
    "description": "Returns the memoized (cached) function.\n\n返回存（缓存）的函数。\n\nCreate an empty cache by instantiating a new `Map` object.\nReturn a function which takes a single argument to be supplied to the memoized function by first checking if the function's output for that specific input value is already cached, or store and return it if not. The `function` keyword must be used in order to allow the memoized function to have its `this` context changed if necessary.\nAllow access to the `cache` by setting it as a property on the returned function.\n\n初始化一个新的`Map`对象作为空缓存。返回一个接收一个参数的函数，用这个参数作为存函数检查这个函数收到指定的输入所得到的输出是否已经被缓存的主要依据。`function`关键字必须按顺序使用，以允许保存函数在必要时改变它的`this`上下文。把`cache`作为返回的函数的一个属性，从而让它可以被访问。\n"
  },
  "merge": {
    "prefix": "30s_merge",
    "body": [
      "const merge = (...objs) =>",
      "  [...objs].reduce(",
      "    (acc, obj) =>",
      "      Object.keys(obj).reduce((a, k) => {",
      "        acc[k] = acc.hasOwnProperty(k) ? [].concat(acc[k]).concat(obj[k]) : obj[k];",
      "        return acc;",
      "      }, {}),",
      "    {}",
      "  );"
    ],
    "description": "Creates a new object from the combination of two or more objects.\n\n结合两个或更多个对象创建一个新的对象。\n\nUse `Array.prototype.reduce()` combined with `Object.keys(obj)` to iterate over all objects and keys.\nUse `hasOwnProperty()` and `Array.prototype.concat()` to append values for keys existing in multiple objects.\n\n所有`Array.prototype.reduce()`结合`Object.keys(obj)`来遍历所有对象和键。使用`hasOwnProperty()`和`Array.prototype.concat()`来给在多个对象中存在的键添加值（形成值数组）。\n"
  },
  "midpoint": {
    "prefix": "30s_midpoint",
    "body": [
      "const midpoint = ([x1, y1], [x2, y2]) => [(x1 + x2) / 2, (y1 + y2) / 2];"
    ],
    "description": "Calculates the midpoint between two pairs of (x,y) points.\n\n计算一对`(x,y)`形式点的中间点。\n\nDestructure the array to get `x1`, `y1`, `x2` and `y2`, calculate the midpoint for each dimension by dividing the sum of the two endpoints by `2`.\n\n解构数组得到`x1`, `y1`, `x2`和`y2`，通过把两个端点的和除以`2`来计算每个维度的中间点。\n"
  },
  "minBy": {
    "prefix": "30s_minBy",
    "body": [
      "const minBy = (arr, fn) => Math.min(...arr.map(typeof fn === 'function' ? fn : val => val[fn]));"
    ],
    "description": "Returns the minimum value of an array, after mapping each element to a value using the provided function.\n\n在给数组中每个元素应用指定的函数后，返回一个其中的最小值。\n\nUse `Array.prototype.map()` to map each element to the value returned by `fn`, `Math.min()` to get the minimum value.\n\n使用`Array.prototype.map()`把每个元素映射到`fn`的返回值，使用`Math.min()`来获取其中最小值。\n"
  },
  "minDate": {
    "prefix": "30s_minDate",
    "body": [
      "const minDate = dates => new Date(Math.min(...dates));"
    ],
    "description": "Returns the minimum of the given dates.\n\nUse the ES6 spread syntax to find the minimum date value, `new Date()` to convert it to a `Date` object.\n\n使用ES6的展开操作符来找到最小的日期值，用`new Date()`把它们转为一个`Date`对象。\n"
  },
  "minN": {
    "prefix": "30s_minN",
    "body": [
      "const minN = (arr, n = 1) => [...arr].sort((a, b) => a - b).slice(0, n);"
    ],
    "description": "Returns the `n` minimum elements from the provided array.\nIf `n` is greater than or equal to the provided array's length, then return the original array (sorted in ascending order).\n\n返回给定数组中最小的`n`个数。如果`n`大于等于给定数组的长度，则返回原始数组（正序排列）。\n\nUse `Array.prototype.sort()` combined with the spread operator (`...`) to create a shallow clone of the array and sort it in ascending order.\nUse `Array.prototype.slice()` to get the specified number of elements.\nOmit the second argument, `n`, to get a one-element array.\n\n使用`Array.prototype.sort()`结合展开操作符(`...`)来创建一个给定数组的浅拷贝，然后对它正序排列。使用`Array.prototype.slice()`来获取元素列表中指定数目的元素。如果不传第二个参数`n`，则只获取一个元素。\n"
  },
  "mostFrequent": {
    "prefix": "30s_mostFrequent",
    "body": [
      "const mostFrequent = arr =>",
      "  Object.entries(",
      "    arr.reduce((a, v) => {",
      "      a[v] = a[v] ? a[v] + 1 : 1;",
      "      return a;",
      "    }, {})",
      "  ).reduce((a, v) => (v[1] >= a[1] ? v : a), [null, 0])[0];"
    ],
    "description": "Returns the most frequent element in an array.\n\nUse `Array.prototype.reduce()` to map unique values to an object's keys, adding to existing keys every time the same value is encountered.\nUse `Object.entries()` on the result in combination with `Array.prototype.reduce()` to get the most frequent value in the array.\n"
  },
  "mostPerformant": {
    "prefix": "30s_mostPerformant",
    "body": [
      "const mostPerformant = (fns, iterations = 10000) => {",
      "  const times = fns.map(fn => {",
      "    const before = performance.now();",
      "    for (let i = 0; i < iterations; i++) fn();",
      "    return performance.now() - before;",
      "  });",
      "  return times.indexOf(Math.min(...times));",
      "};"
    ],
    "description": "Returns the index of the function in an array of functions which executed the fastest.\n\n返回一个函数数组中执行的最快的函数的序号。\n\nUse `Array.prototype.map()` to generate an array where each value is the total time taken to execute the function after `iterations` times. Use the difference in `performance.now()` values before and after to get the total time in milliseconds to a high degree of accuracy.\nUse `Math.min()` to find the minimum execution time, and return the index of that shortest time which corresponds to the index of the most performant function.\nOmit the second argument, `iterations`, to use a default of 10,000 iterations. The more iterations, the more reliable the result but the longer it will take.\n\n使用`Array.prototype.map()`来生成一个元素是每个函数执行`iterations`次后的总时间的数组。使用执行前后的`performance.now()`差值来获取毫秒为单位的总时间，以获取更高精度。使用`Math.min()`来找到最小执行时间，并把相应最高效的函数的序号（即最短的执行时间的序号）返回。如果不传第二个参数`iterations`，则使用默认的10,000次循环。循环次数越多，结果越可靠，但是花费的时间越长。\n"
  },
  "negate": {
    "prefix": "30s_negate",
    "body": [
      "const negate = func => (...args) => !func(...args);"
    ],
    "description": "Negates a predicate function.\n\n否定化一个断言函数。\n\nTake a predicate function and apply the not operator (`!`) to it with its arguments.\n\n接收一个断言函数并把否定操作符(`!`)和参数应用给它。\n"
  },
  "nest": {
    "prefix": "30s_nest",
    "body": [
      "const nest = (items, id = null, link = 'parent_id') =>",
      "  items",
      "    .filter(item => item[link] === id)",
      "    .map(item => ({ ...item, children: nest(items, item.id) }));"
    ],
    "description": "Given a flat array of objects linked to one another, it will nest them recursively.\nUseful for nesting comments, such as the ones on reddit.com.\n\n给出一个相互链接的扁平的对象列表，它将会递归嵌套它们。用来建立嵌套的注释，例如reddit.com上面的。\n\nUse recursion.\nUse `Array.prototype.filter()` to filter the items where the `id` matches the `link`, then `Array.prototype.map()` to map each one to a new object that has a `children` property which recursively nests the items based on which ones are children of the current item.\nOmit the second argument, `id`, to default to `null` which indicates the object is not linked to another one (i.e. it is a top level object).\nOmit the third argument, `link`, to use `'parent_id'` as the default property which links the object to another one by its `id`.\n\n使用递归。使用`Array.prototype.filter()`来过滤出`id`匹配`link`的项，然后使用`Array.prototype.map()`来把每个项映射到拥有一个`children`属性的对象，`children`属性递归嵌套的包含属于当前项目的子项目。如果不传第二个参数`id`，默认值为`null`，代表这个对象不链接到其他对象（例如它是顶层的对象）。如果不传第三个参数`link`，则使用`'parent_id'`作为它的默认值，通过`id`把这个对象链接到另一个。\n"
  },
  "nodeListToArray": {
    "prefix": "30s_nodeListToArray",
    "body": [
      "const nodeListToArray = nodeList => [...nodeList];"
    ],
    "description": "Converts a `NodeList` to an array.\n\n把一个`NodeList`转换成一个数组。\n\nUse spread operator inside new array to convert a `NodeList` to an array.\n\n在新数组内使用展开操作符来把`NodeList`转换成一个数组。\n"
  },
  "none": {
    "prefix": "30s_none",
    "body": [
      "const none = (arr, fn = Boolean) => !arr.some(fn);"
    ],
    "description": "Returns `true` if the provided predicate function returns `false` for all elements in a collection, `false` otherwise.\n\n如果给定集合中所有所有元素应用给定的断言函数都返回`false`，则整体返回`true`；否则返回`false`。\n\nUse `Array.prototype.some()` to test if any elements in the collection return `true` based on `fn`.\nOmit the second argument, `fn`, to use `Boolean` as a default.\n\n使用`Array.prototype.some()`来测试集合中是否有应用`fn`后返回`true`的元素。如果不传第二个参数，则使用`Boolean`作为默认值。\n"
  },
  "nthArg": {
    "prefix": "30s_nthArg",
    "body": [
      "const nthArg = n => (...args) => args.slice(n)[0];"
    ],
    "description": "Creates a function that gets the argument at index `n`. If `n` is negative, the nth argument from the end is returned.\n\n创建一个获取序号`n`位置上的参数的函数。如果`n`是负数，则返回倒数第n个参数。\n\nUse `Array.prototype.slice()` to get the desired argument at index `n`.\n\n使用`Array.prototype.slice()`来获取序号`n`位置上的所需的参数。\n"
  },
  "nthElement": {
    "prefix": "30s_nthElement",
    "body": [
      "const nthElement = (arr, n = 0) => (n === -1 ? arr.slice(n) : arr.slice(n, n + 1))[0];"
    ],
    "description": "Returns the nth element of an array.\n\n返回数组中第nth个元素。\n\nUse `Array.prototype.slice()` to get an array containing the nth element at the first place.\nIf the index is out of bounds, return `undefined`.\nOmit the second argument, `n`, to get the first element of the array.\n\n使用`Array.prototype.slice()`来获得一个把第nth个元素放在开头的新数组。如果index超出边界，返回`undefined`。如果不传第二个参数`n`，则返回数组的第一个元素。\n"
  },
  "objectFromPairs": {
    "prefix": "30s_objectFromPairs",
    "body": [
      "const objectFromPairs = arr => arr.reduce((a, [key, val]) => ((a[key] = val), a), {});"
    ],
    "description": "Creates an object from the given key-value pairs.\n\n从给出的键值对创建一个对象。\n\nUse `Array.prototype.reduce()` to create and combine key-value pairs.\n\n使用`Array.prototype.reduce()`来创建一个对象，它包含了提供的键值对。\n"
  },
  "objectToPairs": {
    "prefix": "30s_objectToPairs",
    "body": [
      "const objectToPairs = obj => Object.keys(obj).map(k => [k, obj[k]]);"
    ],
    "description": "Creates an array of key-value pair arrays from an object.\n\n从一个对象创建一个键值对数组。\n\nUse `Object.keys()` and `Array.prototype.map()` to iterate over the object's keys and produce an array with key-value pairs.\n\n使用`Object.keys()`和`Array.prototype.map()`来遍历对象的键来生成一个键值对数组。\n"
  },
  "objectToQueryString": {
    "prefix": "30s_objectToQueryString",
    "body": [
      "const objectToQueryString = queryParameters => {",
      "  return queryParameters",
      "    ? Object.entries(queryParameters).reduce((queryString, [key, val], index) => {",
      "        const symbol = queryString.length === 0 ? '?' : '&';",
      "        queryString += typeof val === 'string' ? `${symbol}${key}=${val}` : '';",
      "        return queryString;",
      "      }, '')",
      "    : '';",
      "};"
    ],
    "description": "Returns a query string generated from the key-value pairs of the given object.\n\nUse `Array.prototype.reduce()` on `Object.entries(queryParameters)` to create the query string.\nDetermine the `symbol` to be either `?` or `&` based on the `length` of `queryString` and concatenate `val` to `queryString` only if it's a string.\nReturn the `queryString` or an empty string when the `queryParameters` are falsy.\n"
  },
  "observeMutations": {
    "prefix": "30s_observeMutations",
    "body": [
      "const observeMutations = (element, callback, options) => {",
      "  const observer = new MutationObserver(mutations => mutations.forEach(m => callback(m)));",
      "  observer.observe(",
      "    element,",
      "    Object.assign(",
      "      {",
      "        childList: true,",
      "        attributes: true,",
      "        attributeOldValue: true,",
      "        characterData: true,",
      "        characterDataOldValue: true,",
      "        subtree: true",
      "      },",
      "      options",
      "    )",
      "  );",
      "  return observer;",
      "};"
    ],
    "description": "Returns a new MutationObserver and runs the provided callback for each mutation on the specified element.\n\n返回一个新的变化观察者（MutationObserver），对每个给定元素的变化来执行给定的回调函数。\n\nUse a [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) to observe mutations on the given element.\nUse `Array.prototype.forEach()` to run the callback for each mutation that is observed.\nOmit the third argument, `options`, to use the default [options](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationObserverInit) (all `true`).\n\n使用[`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)来观察给定元素的变化。使用`Array.prototype.forEach()`来对每个观察的变化执行回调。如果不传第三个参数`options`，则使用默认的 [options](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationObserverInit)（都是`true`）。\n"
  },
  "off": {
    "prefix": "30s_off",
    "body": [
      "const off = (el, evt, fn, opts = false) => el.removeEventListener(evt, fn, opts);"
    ],
    "description": "Removes an event listener from an element.\n\n删除一个元素中的某个事件监听。\n\nUse `EventTarget.removeEventListener()` to remove an event listener from an element. \nOmit the fourth argument `opts` to use `false` or specify it based on the options used when the event listener was added.\n\n使用`EventTarget.removeEventListener()`来删除一个元素中的某个事件监听。如果不传第四个参数`opts`，则使用`false`或者使用事件监听被添加时候所使用的值。\n"
  },
  "offset": {
    "prefix": "30s_offset",
    "body": [
      "const offset = (arr, offset) => [...arr.slice(offset), ...arr.slice(0, offset)];"
    ],
    "description": "Moves the specified amount of elements to the end of the array.\n\n移除数组尾部指定个数的元素。\n\nUse `Array.prototype.slice()` twice to get the elements after the specified index and the elements before that.\nUse the spread operator(`...`) to combine the two into one array.\nIf `offset` is negative, the elements will be moved from end to start.\n\n使用2次`Array.prototype.slice()`来获取指定序号后面的和前面的元素列表。使用展开操作符(`...`) 来把两个列表合一。如果`offset`是负数，移除的元素则从后向前数。\n"
  },
  "omit": {
    "prefix": "30s_omit",
    "body": [
      "const omit = (obj, arr) =>",
      "  Object.keys(obj)",
      "    .filter(k => !arr.includes(k))",
      "    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});"
    ],
    "description": "Omits the key-value pairs corresponding to the given keys from an object.\n\n根据给出的键列表把一个对象中的键值对去除掉。\n\nUse `Object.keys(obj)`, `Array.prototype.filter()` and `Array.prototype.includes()` to remove the provided keys.\nUse `Array.prototype.reduce()` to convert the filtered keys back to an object with the corresponding key-value pairs.\n\n使用`Object.keys(obj)`, `Array.prototype.filter()`和`Array.prototype.includes()`来删除给出的键列表。使用`Array.prototype.reduce()`来把过滤出的键转换回拥有相应键值对一个对象。\n"
  },
  "omitBy": {
    "prefix": "30s_omitBy",
    "body": [
      "const omitBy = (obj, fn) =>",
      "  Object.keys(obj)",
      "    .filter(k => !fn(obj[k], k))",
      "    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});"
    ],
    "description": "Creates an object composed of the properties the given function returns falsy for. The function is invoked with two arguments: (value, key).\n\n创建一个由给出的函数作用后返回假值的属性组成的对象。这个函数执行时有两个参数：(value, key)。\n\nUse `Object.keys(obj)` and `Array.prototype.filter()`to remove the keys for which `fn` returns a truthy value.\nUse `Array.prototype.reduce()` to convert the filtered keys back to an object with the corresponding key-value pairs.\n\n使用`Object.keys(obj)`和`Array.prototype.filter()`来去除`fn`函数返回真值的键。使用`Array.prototype.reduce()`来把过滤后的键转换回一个包含到对应的键值对的对象。\n"
  },
  "on": {
    "prefix": "30s_on",
    "body": [
      "const on = (el, evt, fn, opts = {}) => {",
      "  const delegatorFn = e => e.target.matches(opts.target) && fn.call(e.target, e);",
      "  el.addEventListener(evt, opts.target ? delegatorFn : fn, opts.options || false);",
      "  if (opts.target) return delegatorFn;",
      "};"
    ],
    "description": "Adds an event listener to an element with the ability to use event delegation.\n\n给一个元素添加一个带有事件委托能力的事件监听。\n\nUse `EventTarget.addEventListener()` to add an event listener to an element. If there is a `target` property supplied to the options object, ensure the event target matches the target specified and then invoke the callback by supplying the correct `this` context.\nReturns a reference to the custom delegator function, in order to be possible to use with [`off`](#off).\nOmit `opts` to default to non-delegation behavior and event bubbling.\n\n使用`EventTarget.addEventListener()`给指定的元素添加一个事件监听。如果options对象中有一个`target`属性，先确保事件目标与给定的目标匹配，然后再提供正确`this`上下文给回调函数，并调用它。返回自定义委托函数的一个引用，用来使用 [`off`](#off)来删除监听时使用。`opts`参数的默认值是不启动委托行为（non-delegation）和事件冒泡传递（非捕获）。\n"
  },
  "once": {
    "prefix": "30s_once",
    "body": [
      "const once = fn => {",
      "  let called = false;",
      "  return function(...args) {",
      "    if (called) return;",
      "    called = true;",
      "    return fn.apply(this, args);",
      "  };",
      "};"
    ],
    "description": "Ensures a function is called only once.\n\n保证一个函数只调用一次。\n\nUtilizing a closure, use a flag, `called`, and set it to `true` once the function is called for the first time, preventing it from being called again. In order to allow the function to have its `this` context changed (such as in an event listener), the `function` keyword must be used, and the supplied function must have the context applied.\nAllow the function to be supplied with an arbitrary number of arguments using the rest/spread (`...`) operator.\n\n利用一个闭包，使用标志位`called`，并在函数第一被调用时把它设置到`true`，以防止它被再次调用。为了让函数可以有特定的`this`上下文（类似在一个事件监听器中），所以要使用函数关键字`function`，提供的函数必须应用了上下文。使用剩余展开操作符(`...`) 来让这个函数支持提供相应参数数目的参数列表。\n"
  },
  "onUserInputChange": {
    "prefix": "30s_onUserInputChange",
    "body": [
      "const onUserInputChange = callback => {",
      "  let type = 'mouse',",
      "    lastTime = 0;",
      "  const mousemoveHandler = () => {",
      "    const now = performance.now();",
      "    if (now - lastTime < 20)",
      "      (type = 'mouse'), callback(type), document.removeEventListener('mousemove', mousemoveHandler);",
      "    lastTime = now;",
      "  };",
      "  document.addEventListener('touchstart', () => {",
      "    if (type === 'touch') return;",
      "    (type = 'touch'), callback(type), document.addEventListener('mousemove', mousemoveHandler);",
      "  });",
      "};"
    ],
    "description": "Run the callback whenever the user input type changes (`mouse` or `touch`). Useful for enabling/disabling code depending on the input device. This process is dynamic and works with hybrid devices (e.g. touchscreen laptops).\n\n只要用户输入变化（`mouse`或者`touch`）都执行回调。用于根据输入设备enabling/disabling代码。这个过程是动态的，并且兼容多种设备（例如：触摸屏的笔记本电脑）。\n\nUse two event listeners. Assume `mouse` input initially and bind a `touchstart` event listener to the document. \nOn `touchstart`, add a `mousemove` event listener to listen for two consecutive `mousemove` events firing within 20ms, using `performance.now()`.\nRun the callback with the input type as an argument in either of these situations.\n\n使用两个事件监听。假设开始是`mouse`输入，则绑定一个`touchstart`事件监听到document上。在`touchstart`事件触发时，添加一个`mousemove`事件监听来监听20ms触发的连续两个`mousemove`事件，时间间隔通过`performance.now()`来计算。在任何一种情况下都把输入类型作为回调函数的一个参数传入并调用它。\n"
  },
  "orderBy": {
    "prefix": "30s_orderBy",
    "body": [
      "const orderBy = (arr, props, orders) =>",
      "  [...arr].sort((a, b) =>",
      "    props.reduce((acc, prop, i) => {",
      "      if (acc === 0) {",
      "        const [p1, p2] = orders && orders[i] === 'desc' ? [b[prop], a[prop]] : [a[prop], b[prop]];",
      "        acc = p1 > p2 ? 1 : p1 < p2 ? -1 : 0;",
      "      }",
      "      return acc;",
      "    }, 0)",
      "  );"
    ],
    "description": "Returns a sorted array of objects ordered by properties and orders.\n\n返回一个根据属性列表和顺序列表来排序的对象数组。\n\nUses `Array.prototype.sort()`, `Array.prototype.reduce()` on the `props` array with a default value of `0`, use array destructuring to swap the properties position depending on the order passed.\nIf no `orders` array is passed it sort by `'asc'` by default.\n\n对`props`（默认值为`0`）数组使用`Array.prototype.sort()`, `Array.prototype.reduce()`，使用数组解构来根据传入的顺序交换属性的位置。如果`orders`数组不传，默认按照`'asc'`顺序排序。\n"
  },
  "over": {
    "prefix": "30s_over",
    "body": [
      "const over = (...fns) => (...args) => fns.map(fn => fn.apply(null, args));"
    ],
    "description": "Creates a function that invokes each provided function with the arguments it receives and returns the results.\n\n创建一个函数，它用接收的参数列表调用每个给定的函数，并返回结果列表。\n\nUse `Array.prototype.map()` and `Function.prototype.apply()` to apply each function to the given arguments.\n\n使用`Array.prototype.map()` 和 `Function.prototype.apply()`来把接收的参数列表应用给每个给定的函数。\n"
  },
  "overArgs": {
    "prefix": "30s_overArgs",
    "body": [
      "const overArgs = (fn, transforms) => (...args) => fn(...args.map((val, i) => transforms[i](val)));"
    ],
    "description": "Creates a function that invokes the provided function with its arguments transformed.\n\n创建一个函数，它用给定的转换后的参数来调用给定的函数。\n\nUse `Array.prototype.map()` to apply `transforms` to `args` in combination with the spread operator (`...`) to pass the transformed arguments to `fn`.\n\n使用`Array.prototype.map()`和展开操作符(`...`)把`transforms`作用于`args`，然后把转换后的参数列表传给`fn`并调用。\n"
  },
  "pad": {
    "prefix": "30s_pad",
    "body": [
      "const pad = (str, length, char = ' ') =>",
      "  str.padStart((str.length + length) / 2, char).padEnd(length, char);"
    ],
    "description": "Pads a string on both sides with the specified character, if it's shorter than the specified length.\n\n如果字符串的长度比指定的长度短，则用指定的字符填充它的两端。\n\nUse `String.padStart()` and `String.padEnd()` to pad both sides of the given string.\nOmit the third argument, `char`, to use the whitespace character as the default padding character.\n\n使用`String.padStart()`和`String.padEnd()`来用指定字符串填充两端。如果不传第三个参数`char`，使用空白字符作为默认的填充字符。\n"
  },
  "palindrome": {
    "prefix": "30s_palindrome",
    "body": [
      "const palindrome = str => {",
      "  const s = str.toLowerCase().replace(/[\\W_]/g, '');",
      "  return s === [...s].reverse().join('');",
      "};"
    ],
    "description": "Returns `true` if the given string is a palindrome, `false` otherwise.\n\n如果给定的字符串是回文的，则返回`true`，否则返回`false`。\n\nConvert the string to `String.prototype.toLowerCase()` and use `String.prototype.replace()` to remove non-alphanumeric characters from it.\nThen, use the spread operator (`...`) to split the string into individual characters, `Array.prototype.reverse()`, `String.prototype.join('')` and compare it to the original, unreversed string, after converting it to `String.prototype.toLowerCase()`.\n\n把字符串转换到`String.prototype.toLowerCase()`，并使用`String.prototype.replace()`从其中删除非数字和字母的字符。然后，使用展开操作符(`...`)来把字符串分解成独立的字符，使用`Array.prototype.reverse()`, `String.prototype.join('')`并把它在`String.prototype.toLowerCase()`后和原始的未翻转的字符串比较。\n"
  },
  "parseCookie": {
    "prefix": "30s_parseCookie",
    "body": [
      "const parseCookie = str =>",
      "  str",
      "    .split(';')",
      "    .map(v => v.split('='))",
      "    .reduce((acc, v) => {",
      "      acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim());",
      "      return acc;",
      "    }, {});"
    ],
    "description": "Parse an HTTP Cookie header string and return an object of all cookie name-value pairs.\n\n解析一个HTTP Cookie头字符串，并返回一个包含所有cookie键值对的对象。\n\nUse `String.prototype.split(';')` to separate key-value pairs from each other.\nUse `Array.prototype.map()` and `String.prototype.split('=')` to separate keys from values in each pair.\nUse `Array.prototype.reduce()` and `decodeURIComponent()` to create an object with all key-value pairs.\n\n使用`String.prototype.split(';')`来把每个键值对分隔开。使用`Array.prototype.map()`和`String.prototype.split('=')`来从每个对中分隔键和值。使用`Array.prototype.reduce()`和`decodeURIComponent()`来创建一个包含所有键值对的对象。\n"
  },
  "partial": {
    "prefix": "30s_partial",
    "body": [
      "const partial = (fn, ...partials) => (...args) => fn(...partials, ...args);"
    ],
    "description": "Creates a function that invokes `fn` with `partials` prepended to the arguments it receives.\n\n创建一个用部分参数`partials`结合新接收的参数来执行`fn`的函数。\n\nUse the spread operator (`...`) to prepend `partials` to the list of arguments of `fn`.\n\n使用展开操作符(`...`)来把`partials`放到`fn`的参数列表前部。\n"
  },
  "partialRight": {
    "prefix": "30s_partialRight",
    "body": [
      "const partialRight = (fn, ...partials) => (...args) => fn(...args, ...partials);"
    ],
    "description": "Creates a function that invokes `fn` with `partials` appended to the arguments it receives.\n\n创建一个用部分参数`partials`放到新接收的参数尾部来执行`fn`的函数。\n\nUse the spread operator (`...`) to append `partials` to the list of arguments of `fn`.\n\n使用展开操作符(`...`)来把`partials`放到`fn`的参数列表尾部。\n"
  },
  "partition": {
    "prefix": "30s_partition",
    "body": [
      "const partition = (arr, fn) =>",
      "  arr.reduce(",
      "    (acc, val, i, arr) => {",
      "      acc[fn(val, i, arr) ? 0 : 1].push(val);",
      "      return acc;",
      "    },",
      "    [[], []]",
      "  );"
    ],
    "description": "Groups the elements into two arrays, depending on the provided function's truthiness for each element.\n\n基于给定的函数对于每个元素的真值，把元素分为两组。\n\nUse `Array.prototype.reduce()` to create an array of two arrays.\nUse `Array.prototype.push()` to add elements for which `fn` returns `true` to the first array and elements for which `fn` returns `false` to the second one.\n\n使用`Array.prototype.reduce()`来创建一个包含两个数组的新数组。使用`Array.prototype.push()`把`fn`作用后返回`true`的元素添加到第一个数组中，返回`false`的元素添加到第二个数组中。\n"
  },
  "percentile": {
    "prefix": "30s_percentile",
    "body": [
      "const percentile = (arr, val) =>",
      "  (100 * arr.reduce((acc, v) => acc + (v < val ? 1 : 0) + (v === val ? 0.5 : 0), 0)) / arr.length;"
    ],
    "description": "Uses the percentile formula to calculate how many numbers in the given array are less or equal to the given value.\n\n使用百分号公式来计算给定的数组中有多少个数字小于等于给定的值。\n\nUse `Array.prototype.reduce()` to calculate how many numbers are below the value and how many are the same value and apply the percentile formula.\n\n使用`Array.prototype.reduce()`来计算多少数字小于给定值，多少是相同的值，并且应用百分比公式。\n"
  },
  "permutations": {
    "prefix": "30s_permutations",
    "body": [
      "const permutations = arr => {",
      "  if (arr.length <= 2) return arr.length === 2 ? [arr, [arr[1], arr[0]]] : arr;",
      "  return arr.reduce(",
      "    (acc, item, i) =>",
      "      acc.concat(",
      "        permutations([...arr.slice(0, i), ...arr.slice(i + 1)]).map(val => [item, ...val])",
      "      ),",
      "    []",
      "  );",
      "};"
    ],
    "description": "Generates all permutations of an array's elements (contains duplicates).\n\n生成数组中元素的所有排列。（包含重复组合）\n\n⚠️ **WARNING**: This function's execution time increases exponentially with each array element. Anything more than 8 to 10 entries will cause your browser to hang as it tries to solve all the different combinations.\n\n⚠️ **WARNING**: 本函数的执行时间随着数组元素个数指数级增长。任何超过8~10个元素的数组会导致浏览器尝因试不同的组合而导致挂起（大量同步计算导致无响应）。\n\nUse recursion.\nFor each element in the given array, create all the partial permutations for the rest of its elements.\nUse `Array.prototype.map()` to combine the element with each partial permutation, then `Array.prototype.reduce()` to combine all permutations in one array.\nBase cases are for array `length` equal to `2` or `1`.\n\n使用递归。对给定数组中每个元素，创建除它以外所有元素的排列。使用`Array.prototype.map()`来把这个元素和每个剩余部分的排列结合，然后使用`Array.prototype.reduce()`把所有排列结合成一个数组。\n"
  },
  "pick": {
    "prefix": "30s_pick",
    "body": [
      "const pick = (obj, arr) =>",
      "  arr.reduce((acc, curr) => (curr in obj && (acc[curr] = obj[curr]), acc), {});"
    ],
    "description": "Picks the key-value pairs corresponding to the given keys from an object.\n\n根据给定的键列表从一个对象中挑选出相应的键值对。\n\nUse `Array.prototype.reduce()` to convert the filtered/picked keys back to an object with the corresponding key-value pairs if the key exists in the object.\n\n使用`Array.prototype.reduce()`遍历过滤/挑选出的键列表，如果键存在于原对象中，则把相应的键值对转换回新的对象中。\n"
  },
  "pickBy": {
    "prefix": "30s_pickBy",
    "body": [
      "const pickBy = (obj, fn) =>",
      "  Object.keys(obj)",
      "    .filter(k => fn(obj[k], k))",
      "    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});"
    ],
    "description": "Creates an object composed of the properties the given function returns truthy for. The function is invoked with two arguments: (value, key).\n\n创建一个给定的函数返回真值的属性组成的对象。这个函数接受两个参数：(value, key)。\n\nUse `Object.keys(obj)` and `Array.prototype.filter()`to remove the keys for which `fn` returns a falsy value.\nUse `Array.prototype.reduce()` to convert the filtered keys back to an object with the corresponding key-value pairs.\n\n使用`Object.keys(obj)`和`Array.prototype.filter()`来把`fn`返回假值的键删除。使用`Array.prototype.reduce()`把过滤出来的键列表用相应的键值对转换回一个新对象中。\n"
  },
  "pipeAsyncFunctions": {
    "prefix": "30s_pipeAsyncFunctions",
    "body": [
      "const pipeAsyncFunctions = (...fns) => arg => fns.reduce((p, f) => p.then(f), Promise.resolve(arg));"
    ],
    "description": "Performs left-to-right function composition for asynchronous functions.\n\n为异步函数列表产生一个从左向右执行的函数组合。\n\nUse `Array.prototype.reduce()` with the spread operator (`...`) to perform left-to-right function composition using `Promise.then()`.\nThe functions can return a combination of: simple values, `Promise`'s, or they can be defined as `async` ones returning through `await`.\n\n使用`Array.prototype.reduce()`和展开操作符(`...`) 来从左向右执行 `Promise.then()`的函数组合。这些函数可以返回一下结果：简单值，`Promise`，或者通过`await`执行的`async`函数。\n\nAll functions must be unary.\n\n所有函数必须是一元的（接受一个参数）。\n"
  },
  "pipeFunctions": {
    "prefix": "30s_pipeFunctions",
    "body": [
      "const pipeFunctions = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args))); // 把前一个函数的返回值作为当前函数的参数"
    ],
    "description": "Performs left-to-right function composition.\n\n从左向右执行一个函数组合。\n\nUse `Array.prototype.reduce()` with the spread operator (`...`) to perform left-to-right function composition.\nThe first (leftmost) function can accept one or more arguments; the remaining functions must be unary.\n\n使用`Array.prototype.reduce()`和展开操作符(`...`) 来从左向右执行函数组合。第一个（最左边）的函数可以接受一个或多个参数；剩下的函数必须是一元的（接受一个参数）。\n"
  },
  "pluralize": {
    "prefix": "30s_pluralize",
    "body": [
      "const pluralize = (val, word, plural = word + 's') => {",
      "  const _pluralize = (num, word, plural = word + 's') =>",
      "    [1, -1].includes(Number(num)) ? word : plural;",
      "  if (typeof val === 'object') return (num, word) => _pluralize(num, word, val[word]);",
      "  return _pluralize(val, word, plural);",
      "};"
    ],
    "description": "Returns the singular or plural form of the word based on the input number. If the first argument is an `object`, it will use a closure by returning a function that can auto-pluralize words that don't simply end in `s` if the supplied dictionary contains the word.\n\n根据输入的数字返回单词的单数或者复数形式。如果第一个参数是`object`，他将返回一个可以自动的把单词列表复数化的函数闭包，这个函数根据给出的字典（`object`）来判断并非简单的以`s`结尾的单词，并转化它。\n\nIf `num` is either `-1` or `1`, return the singular form of the word. If `num` is any other number, return the plural form. Omit the third argument to use the default of the singular word + `s`, or supply a custom pluralized word when necessary. If the first argument is an `object`, utilize a closure by returning a function which can use the supplied dictionary to resolve the correct plural form of the word.\n\n如果`num`是`1`或`-1`，返回单词的单数形式。如果`num`是其他任何数，返回复数形式。如果不传第三个参数，则使用单数单词+`s`，或者当必要时提供一个自定义的复数形式。如果第一个参数是`object`，返回一个使用提供的字典来解析单词的正确复数形式的函数闭包。\n"
  },
  "powerset": {
    "prefix": "30s_powerset",
    "body": [
      "const powerset = arr => arr.reduce((a, v) => a.concat(a.map(r => [v].concat(r))), [[]]);"
    ],
    "description": "Returns the powerset of a given array of numbers.\n\n返回给定的数字数组的幂集合。\n\nUse `Array.prototype.reduce()` combined with `Array.prototype.map()` to iterate over elements and combine into an array containing all combinations.\n\n使用`Array.prototype.reduce()`结合`Array.prototype.map()`来遍历所有元素并将结果结合到一个包含所有组合情况的数组中。\n"
  },
  "prefix": {
    "prefix": "30s_prefix",
    "body": [
      "const prefix = prop => {",
      "  const capitalizedProp = prop.charAt(0).toUpperCase() + prop.slice(1);",
      "  const prefixes = ['', 'webkit', 'moz', 'ms', 'o'];",
      "  const i = prefixes.findIndex(",
      "    prefix => typeof document.body.style[prefix ? prefix + capitalizedProp : prop] !== 'undefined'",
      "  );",
      "  return i !== -1 ? (i === 0 ? prop : prefixes[i] + capitalizedProp) : null;",
      "};"
    ],
    "description": "Returns the prefixed version (if necessary) of a CSS property that the browser supports.\n\n返回一个浏览器支持的CSS属性的前缀版本（如果需要的话）。\n\nUse `Array.prototype.findIndex()` on an array of vendor prefix strings to test if `document.body` has one of them defined in its `CSSStyleDeclaration` object, otherwise return `null`.\nUse `String.prototype.charAt()` and `String.prototype.toUpperCase()` to capitalize the property, which will be appended to the vendor prefix string.\n\n对一个浏览器引擎前缀字符串数组使用`Array.prototype.findIndex()`来测试`document.body`的`CSSStyleDeclaration`对象中是否有其中之一，否则返回`null`。使用`String.prototype.charAt()`和`String.prototype.toUpperCase()`来把要添加的浏览器引擎前缀字符串后面的属性转换为大写开头。\n"
  },
  "prettyBytes": {
    "prefix": "30s_prettyBytes",
    "body": [
      "const prettyBytes = (num, precision = 3, addSpace = true) => {",
      "  const UNITS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];",
      "  if (Math.abs(num) < 1) return num + (addSpace ? ' ' : '') + UNITS[0];",
      "  const exponent = Math.min(Math.floor(Math.log10(num < 0 ? -num : num) / 3), UNITS.length - 1);",
      "  const n = Number(((num < 0 ? -num : num) / 1000 ** exponent).toPrecision(precision));",
      "  return (num < 0 ? '-' : '') + n + (addSpace ? ' ' : '') + UNITS[exponent];",
      "};"
    ],
    "description": "Converts a number in bytes to a human-readable string.\n\n把一个字节形式的数字转换为一个人类可读字符串。\n\nUse an array dictionary of units to be accessed based on the exponent.\nUse `Number.toPrecision()` to truncate the number to a certain number of digits.\nReturn the prettified string by building it up, taking into account the supplied options and whether it is negative or not.\nOmit the second argument, `precision`, to use a default precision of `3` digits.\nOmit the third argument, `addSpace`, to add space between the number and unit by default.\n\n使用一个根据指数来判断单位的字典数组。使用`Number.toPrecision()`来把数字截断为一个特定的位数。根据提供的选项还有它是否为负数来创建一个易读的字符串并返回。如果不传第二个参数`precision`，则使用`3`位精度作为默认值。如果不传第三个参数`addSpace`，则默认在数字和单位中间添加一个空格。\n"
  },
  "primes": {
    "prefix": "30s_primes",
    "body": [
      "const primes = num => {",
      "  let arr = Array.from({ length: num - 1 }).map((x, i) => i + 2),",
      "    sqroot = Math.floor(Math.sqrt(num)),",
      "    numsTillSqroot = Array.from({ length: sqroot - 1 }).map((x, i) => i + 2);",
      "  numsTillSqroot.forEach(x => (arr = arr.filter(y => y % x !== 0 || y === x)));",
      "  return arr;",
      "};"
    ],
    "description": "Generates primes up to a given number, using the Sieve of Eratosthenes.\n\n使用Sieve of Eratosthenes方法生成以给定数字为上限的质数数组。\n\nGenerate an array from `2` to the given number. Use `Array.prototype.filter()` to filter out the values divisible by any number from `2` to the square root of the provided number.\n\n生成从`2`到给定数字的数组。使用`Array.prototype.filter()`来过滤掉可以被某个从`2`到它本身的平方根中任意数字整除的数字（即过滤掉非质数）。\n"
  },
  "promisify": {
    "prefix": "30s_promisify",
    "body": [
      "const promisify = func => (...args) =>",
      "  new Promise((resolve, reject) =>",
      "    func(...args, (err, result) => (err ? reject(err) : resolve(result)))",
      "  );"
    ],
    "description": "Converts an asynchronous function to return a promise.\n\n把一个异步函数转换为返回promise的函数（很适合将Node中回调模式的函数转为promise）。\n\n*In Node 8+, you can use [`util.promisify`](https://nodejs.org/api/util.html#util_util_promisify_original)*\n*在Node 8+环境，你可以直接使用[`util.promisify`](https://nodejs.org/api/util.html#util_util_promisify_original)*\n\nUse currying to return a function returning a `Promise` that calls the original function.\nUse the `...rest` operator to pass in all the parameters.\n\n使用柯里化来返回一个调用原函数并且返回`Promise`的函数。使用 `...rest` 操作符来传入所有参数。\n"
  },
  "pull": {
    "prefix": "30s_pull",
    "body": [
      "const pull = (arr, ...args) => {",
      "  let argState = Array.isArray(args[0]) ? args[0] : args;",
      "  let pulled = arr.filter(v => !argState.includes(v));",
      "  arr.length = 0;",
      "  pulled.forEach(v => arr.push(v));",
      "};"
    ],
    "description": "Mutates the original array to filter out the values specified.\n\n从一个原始数组中过滤掉给定的值（直接改变原始数组）。\n\nUse `Array.prototype.filter()` and `Array.prototype.includes()` to pull out the values that are not needed.\nUse `Array.prototype.length = 0` to mutate the passed in an array by resetting it's length to zero and `Array.prototype.push()` to re-populate it with only the pulled values.\n\n使用`Array.prototype.filter()`和`Array.prototype.includes()`把不需要的值去掉。使用`Array.prototype.length = 0`，通过把数组的长度置为0重置传入的值，再使用`Array.prototype.push()`，用提取出来的值来重新建立数组。\n\n_(For a snippet that does not mutate the original array see [`without`](#without))_\n\n_(不改变原始数组的代码片段参见 [`without`](#without))_\n"
  },
  "pullAtIndex": {
    "prefix": "30s_pullAtIndex",
    "body": [
      "const pullAtIndex = (arr, pullArr) => {",
      "  let removed = [];",
      "  let pulled = arr",
      "    .map((v, i) => (pullArr.includes(i) ? removed.push(v) : v))",
      "    .filter((v, i) => !pullArr.includes(i));",
      "  arr.length = 0;",
      "  pulled.forEach(v => arr.push(v));",
      "  return removed;",
      "};"
    ],
    "description": "Mutates the original array to filter out the values at the specified indexes.\n\n从一个原始数组中过滤掉给定的序号的元素（直接改变原始数组）。\n\nUse `Array.prototype.filter()` and `Array.prototype.includes()` to pull out the values that are not needed.\nUse `Array.prototype.length = 0` to mutate the passed in an array by resetting it's length to zero and `Array.prototype.push()` to re-populate it with only the pulled values.\nUse `Array.prototype.push()` to keep track of pulled values.\n\n使用`Array.prototype.filter()`和`Array.prototype.includes()`去掉不需要的值。使用`Array.prototype.length = 0`，通过把数组的长度置为0重置传入的值，再使用`Array.prototype.push()`，用提取出来的值来重新建立数组。使用`Array.prototype.push()`记录提取出来的值。\n"
  },
  "pullAtValue": {
    "prefix": "30s_pullAtValue",
    "body": [
      "const pullAtValue = (arr, pullArr) => {",
      "  let removed = [],",
      "    pushToRemove = arr.forEach((v, i) => (pullArr.includes(v) ? removed.push(v) : v)),",
      "    mutateTo = arr.filter((v, i) => !pullArr.includes(v));",
      "  arr.length = 0;",
      "  mutateTo.forEach(v => arr.push(v));",
      "  return removed;",
      "};"
    ],
    "description": "Mutates the original array to filter out the values specified. Returns the removed elements.\n\n改变原始数组，过滤掉指定的值。返回被过滤掉的元素。\n\nUse `Array.prototype.filter()` and `Array.prototype.includes()` to pull out the values that are not needed.\nUse `Array.prototype.length = 0` to mutate the passed in an array by resetting it's length to zero and `Array.prototype.push()` to re-populate it with only the pulled values.\nUse `Array.prototype.push()` to keep track of pulled values.\n\n使用`Array.prototype.filter()`和`Array.prototype.includes()`去掉不需要的值。使用`Array.prototype.length = 0`，通过把数组的长度置为0重置传入的值；再使用`Array.prototype.push()`，用提取出来的值来重新建立数组。使用`Array.prototype.push()`记录提取出来的值。\n"
  },
  "pullBy": {
    "prefix": "30s_pullBy",
    "body": [
      "const pullBy = (arr, ...args) => {",
      "  const length = args.length;",
      "  let fn = length > 1 ? args[length - 1] : undefined;",
      "  fn = typeof fn == 'function' ? (args.pop(), fn) : undefined;",
      "  let argState = (Array.isArray(args[0]) ? args[0] : args).map(val => fn(val));",
      "  let pulled = arr.filter((v, i) => !argState.includes(fn(v)));",
      "  arr.length = 0;",
      "  pulled.forEach(v => arr.push(v));",
      "};"
    ],
    "description": "Mutates the original array to filter out the values specified, based on a given iterator function.\n\n改变原始数组，基于给定的遍历函数来过滤掉给定的值。\n\nCheck if the last argument provided in a function.\nUse `Array.prototype.map()` to apply the iterator function `fn` to all array elements.\nUse `Array.prototype.filter()` and `Array.prototype.includes()` to pull out the values that are not needed.\nUse `Array.prototype.length = 0` to mutate the passed in an array by resetting it's length to zero and `Array.prototype.push()` to re-populate it with only the pulled values.\n\n检查最后一个参数是否是函数类型。使用`Array.prototype.map()`来对数组中所有元素遍历调用`fn`。使用`Array.prototype.filter()` 和 `Array.prototype.includes()`来去除掉不需要的值。使用`Array.prototype.length = 0`，通过把数组的长度置为0重置传入的值；再使用`Array.prototype.push()`，用提取出来的值来重新建立数组。\n"
  },
  "radsToDegrees": {
    "prefix": "30s_radsToDegrees",
    "body": [
      "const radsToDegrees = rad => (rad * 180.0) / Math.PI;"
    ],
    "description": "Converts an angle from radians to degrees.\n\n把一个角从弧度转换为弧度。\n\nUse `Math.PI` and the radian to degree formula to convert the angle from radians to degrees.\n\n使用`Math.PI`和弧度到角度公式来把角的弧度转为角度。\n"
  },
  "randomHexColorCode": {
    "prefix": "30s_randomHexColorCode",
    "body": [
      "const randomHexColorCode = () => {",
      "  let n = (Math.random() * 0xfffff * 1000000).toString(16);",
      "  return '#' + n.slice(0, 6);",
      "};"
    ],
    "description": "Generates a random hexadecimal color code.\n\n生成一个随机的十六进制颜色码。\n\nUse `Math.random` to generate a random 24-bit(6x4bits) hexadecimal number. Use bit shifting and then convert it to an hexadecimal String using `toString(16)`.\n\n使用`Math.random`来生成一个随机的24-bit(6x4bits)十六进制数字。使用位移，然后使用`toString(16)`把它转换为一个十六进制的String。\n"
  },
  "randomIntArrayInRange": {
    "prefix": "30s_randomIntArrayInRange",
    "body": [
      "const randomIntArrayInRange = (min, max, n = 1) =>",
      "  Array.from({ length: n }, () => Math.floor(Math.random() * (max - min + 1)) + min);"
    ],
    "description": "Returns an array of n random integers in the specified range.\n\n返回一个指定范围内的随机整数数组。\n\nUse `Array.from()` to create an empty array of the specific length, `Math.random()` to generate a random number and map it to the desired range, using `Math.floor()` to make it an integer.\n\n使用`Array.from()`来创建一个指定长度的空数组，使用`Math.random()`来生成一个随机数并把它映射到这个期望的范围，使用`Math.floor()`来把它变为整数。\n"
  },
  "randomIntegerInRange": {
    "prefix": "30s_randomIntegerInRange",
    "body": [
      "const randomIntegerInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;"
    ],
    "description": "Returns a random integer in the specified range.\n\n返回指定范围内的一个随机整数。\n\nUse `Math.random()` to generate a random number and map it to the desired range, using `Math.floor()` to make it an integer.\n\n使用`Math.random()`来生成一个随机数，然后把它映射到指定范围，使用`Math.floor()`来把它变为整数。\n"
  },
  "randomNumberInRange": {
    "prefix": "30s_randomNumberInRange",
    "body": [
      "const randomNumberInRange = (min, max) => Math.random() * (max - min) + min;"
    ],
    "description": "Returns a random number in the specified range.\n\n返回指定范围内的一个随机数。\n\nUse `Math.random()` to generate a random value, map it to the desired range using multiplication.\n\n使用`Math.random()`来生成一个随机数，然后使用乘法把它映射到指定范围。\n"
  },
  "readFileLines": {
    "prefix": "30s_readFileLines",
    "body": [
      "const fs = require('fs');",
      "const readFileLines = filename =>",
      "  fs",
      "    .readFileSync(filename)",
      "    .toString('UTF8')",
      "    .split('\\n');"
    ],
    "description": "Returns an array of lines from the specified file.\n\n返回一个从指定文件中读取的行数组。\n\nUse `readFileSync` function in `fs` node package to create a `Buffer` from a file.\nconvert buffer to string using `toString(encoding)` function.\ncreating an array from contents of file by `split`ing file content line by line (each `\\n`).\n\n使用`fs`node包中的`readFileSync`函数从文件创建一个`Buffer`。用`toString(encoding)`函数把buffer转到字符串。通过把文件内容一行一行（每`\\n`）的`split`开，创建一个文件内容的数组。\n"
  },
  "rearg": {
    "prefix": "30s_rearg",
    "body": [
      "const rearg = (fn, indexes) => (...args) => fn(...indexes.map(i => args[i]));"
    ],
    "description": "Creates a function that invokes the provided function with its arguments arranged according to the specified indexes.\n\n用给定的函数创建一个新函数，新函数的参数按照指定顺序重新排序传入。\n\nUse `Array.prototype.map()` to reorder arguments based on `indexes` in combination with the spread operator (`...`) to pass the transformed arguments to `fn`.\n\n使用 `Array.prototype.map()`把参数根据传入的`indexes`重新排序，然后使用展开操作符(`...`)把转换后的参数列表传给`fn`。\n"
  },
  "recordAnimationFrames": {
    "prefix": "30s_recordAnimationFrames",
    "body": [
      "const recordAnimationFrames = (callback, autoStart = true) => {",
      "  let running = true,",
      "    raf;",
      "  const stop = () => {",
      "    running = false;",
      "    cancelAnimationFrame(raf);",
      "  };",
      "  const start = () => {",
      "    running = true;",
      "    run();",
      "  };",
      "  const run = () => {",
      "    raf = requestAnimationFrame(() => {",
      "      callback();",
      "      if (running) run();",
      "    });",
      "  };",
      "  if (autoStart) start();",
      "  return { start, stop };",
      "};"
    ],
    "description": "Invokes the provided callback on each animation frame.\n\n对每个动画frame来执行给定的回调函数。\n\nUse recursion. \nProvided that `running` is `true`, continue invoking `window.requestAnimationFrame()` which invokes the provided callback. \nReturn an object with two methods `start` and `stop` to allow manual control of the recording. \nOmit the second argument, `autoStart`, to implicitly call `start` when the function is invoked.\n\n使用递归。如果`running`是`true`，则继续去触发执行给定回调的`window.requestAnimationFrame()` 。返回一个有两个方法`start`和`stop`的对象来允许记录的手动控制。如果不传第二个参数`autoStart`，则在调用给定函数的时候隐式的调用`start`。\n"
  },
  "redirect": {
    "prefix": "30s_redirect",
    "body": [
      "const redirect = (url, asLink = true) =>",
      "  asLink ? (window.location.href = url) : window.location.replace(url);"
    ],
    "description": "Redirects to a specified URL.\n\n重定向到一个特定的URL。\n\nUse `window.location.href` or `window.location.replace()` to redirect to `url`.\nPass a second argument to simulate a link click (`true` - default) or an HTTP redirect (`false`).\n\n使用`window.location.href`或者`window.location.replace()`来重定向到`url`。传入第二个参数来决定模拟一个链接点击（传入`true`）还是一个HTTP重定向（传入`false`）。\n"
  },
  "reducedFilter": {
    "prefix": "30s_reducedFilter",
    "body": [
      "const reducedFilter = (data, keys, fn) =>",
      "  data.filter(fn).map(el =>",
      "    keys.reduce((acc, key) => {",
      "      acc[key] = el[key];",
      "      return acc;",
      "    }, {})",
      "  );"
    ],
    "description": "Filter an array of objects based on a condition while also filtering out unspecified keys.\n\n根据条件过滤一个对象数组，并把元素对象的没有指定的属性过滤掉（不在`keys`中的属性）。\n\nUse `Array.prototype.filter()` to filter the array based on the predicate `fn` so that it returns the objects for which the condition returned a truthy value.\nOn the filtered array, use `Array.prototype.map()` to return the new object using `Array.prototype.reduce()` to filter out the keys which were not supplied as the `keys` argument.\n\n使用`Array.prototype.filter()`根据断言函数`fn`来过滤数组，返回条件为真值的对象。再对过滤后的数组，使用`Array.prototype.map()`来过滤掉`keys`参数中没有给出的属性。\n"
  },
  "reduceSuccessive": {
    "prefix": "30s_reduceSuccessive",
    "body": [
      "const reduceSuccessive = (arr, fn, acc) =>",
      "  arr.reduce((res, val, i, arr) => (res.push(fn(res.slice(-1)[0], val, i, arr)), res), [acc]);"
    ],
    "description": "Applies a function against an accumulator and each element in the array (from left to right), returning an array of successively reduced values.\n\n对一个累加器和数组中每一个元素应用给定函数（从左向右），返回每一步累加值组成的数组。\n\nUse `Array.prototype.reduce()` to apply the given function to the given array, storing each new result.\n\n使用`Array.prototype.reduce()`来对给定的数组应用给定的函数，存储每一次新的累加结果。\n"
  },
  "reduceWhich": {
    "prefix": "30s_reduceWhich",
    "body": [
      "const reduceWhich = (arr, comparator = (a, b) => a - b) =>",
      "  arr.reduce((a, b) => (comparator(a, b) >= 0 ? b : a));"
    ],
    "description": "Returns the minimum/maximum value of an array, after applying the provided function to set comparing rule.\n\n使用给定的函数作为比较规则，返回一个数组的最小值/最大值。\n\nUse `Array.prototype.reduce()` in combination with the `comparator` function to get the appropriate element in the array.\nYou can omit the second parameter, `comparator`, to use the default one that returns the minimum element in the array.\n\n使用`Array.prototype.reduce()`结合`comparator`函数来获取数组中合适的元素。如果不传第二个参数`comparator`，使用一个返回数组中最小值的函数作为默认值。\n"
  },
  "reject": {
    "prefix": "30s_reject",
    "body": [
      "const reject = (pred, array) => array.filter((...args) => !pred(...args));"
    ],
    "description": "Filters an array's values based on a predicate function, returning only values for which the predicate function returns `true`.\n\nUse `Array.prototype.filter()` in combination with the predicate function, `pred`, to return only the values for which `pred()` returns `true`.\n\n接受一个断言函数和数组，有点类似`Array.prototype.filter()`，但在`pred(x) === false`时保留`x`（就是过滤掉pred(x)为真的`x`）。\n"
  },
  "remove": {
    "prefix": "30s_remove",
    "body": [
      "const remove = (arr, func) =>",
      "  Array.isArray(arr)",
      "    ? arr.filter(func).reduce((acc, val) => {",
      "      arr.splice(arr.indexOf(val), 1);",
      "      return acc.concat(val);",
      "    }, [])",
      "    : [];"
    ],
    "description": "Removes elements from an array for which the given function returns `false`.\n\n把数组中给定函数作用后返回`false`的元素删除。\n\nUse `Array.prototype.filter()` to find array elements that return truthy values and `Array.prototype.reduce()` to remove elements using `Array.prototype.splice()`.\nThe `func` is invoked with three arguments (`value, index, array`).\n\n使用`Array.prototype.filter()`来找到数组中的返回真值的元素，并使用`Array.prototype.reduce()`和`Array.prototype.splice()`去除掉它。`func`回调支持三个参数(`value, index, array`)。\n"
  },
  "removeNonASCII": {
    "prefix": "30s_removeNonASCII",
    "body": [
      "const removeNonASCII = str => str.replace(/[^\\x20-\\x7E]/g, '');"
    ],
    "description": "Removes non-printable ASCII characters.\n\n删除非打印ASCII字符。\n\nUse a regular expression to remove non-printable ASCII characters.\n\n使用一个正则表达式来删除非打印ASCII字符。\n"
  },
  "renameKeys": {
    "prefix": "30s_renameKeys",
    "body": [
      "const renameKeys = (keysMap, obj) =>",
      "  Object.keys(obj).reduce(",
      "    (acc, key) => ({",
      "      ...acc,",
      "      ...{ [keysMap[key] || key]: obj[key] }",
      "    }),",
      "    {}",
      "  );"
    ],
    "description": "Replaces the names of multiple object keys with the values provided.\n\n用给定的值列表替换多个对象中键的名字。\n\nUse `Object.keys()` in combination with `Array.prototype.reduce()` and the spread operator (`...`) to get the object's keys and rename them according to `keysMap`.\n\n使用`Object.keys()`结合`Array.prototype.reduce()`还有展开操作符(`...`)来获取对象的键列表，并根据`keysMap`重命名它们。\n"
  },
  "reverseString": {
    "prefix": "30s_reverseString",
    "body": [
      "const reverseString = str => [...str].reverse().join('');"
    ],
    "description": "Reverses a string.\n\n翻转一个字符串。\n\nUse the spread operator (`...`) and `Array.prototype.reverse()` to reverse the order of the characters in the string.\nCombine characters to get a string using `String.prototype.join('')`.\n\n使用展开操作符(`...`)和`Array.prototype.reverse()`来翻转字符串中字符的顺序。使用`String.prototype.join('')`来结合这些字符来获得一个字符串。\n"
  },
  "RGBToHex": {
    "prefix": "30s_RGBToHex",
    "body": [
      "const RGBToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');"
    ],
    "description": "Converts the values of RGB components to a color code.\n\n把一个RGB组合值转换为颜色码。\n\nConvert given RGB parameters to hexadecimal string using bitwise left-shift operator (`<<`) and `toString(16)`, then `String.padStart(6,'0')` to get a 6-digit hexadecimal value.\n\n使用向左位移操作符(`<<`)和`toString(16)`来把RGB参数转换为十六进制字符串，然后使用`String.padStart(6,'0')`来获取一个6位的十六进制值。\n"
  },
  "round": {
    "prefix": "30s_round",
    "body": [
      "const round = (n, decimals = 0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`);"
    ],
    "description": "Rounds a number to a specified amount of digits.\n\n返回一个指定精度的数字的近似值。\n\nUse `Math.round()` and template literals to round the number to the specified number of digits.\nOmit the second argument, `decimals` to round to an integer.\n\n使用`Math.round()`和模板字面量来把这个数字近似到指定的位数。如果不传第二个参数`decimals`，则近似到一个整数。\n"
  },
  "runAsync": {
    "prefix": "30s_runAsync",
    "body": [
      "const runAsync = fn => {",
      "  const worker = new Worker(",
      "    URL.createObjectURL(new Blob([`postMessage((${fn})());`]), {",
      "      type: 'application/javascript; charset=utf-8'",
      "    })",
      "  );",
      "  return new Promise((res, rej) => {",
      "    worker.onmessage = ({ data }) => {",
      "      res(data), worker.terminate();",
      "    };",
      "    worker.onerror = err => {",
      "      rej(err), worker.terminate();",
      "    };",
      "  });",
      "};"
    ],
    "description": "Runs a function in a separate thread by using a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers), allowing long running functions to not block the UI.\n\n使用[Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)在单独的线程中运行一个函数，支持持续运行的函数不阻塞UI。\n\nCreate a new `Worker` using a `Blob` object URL, the contents of which should be the stringified version of the supplied function.\nImmediately post the return value of calling the function back.\nReturn a promise, listening for `onmessage` and `onerror` events and resolving the data posted back from the worker, or throwing an error.\n\n用`Blob`对象URL来创建一个新的`Worker`，它的内容应该是给出函数的序列化版本。立即发送包含函数的返回值的请求。监听`onmessage`和`onerror`来返回一个promise，并把从worker返回的请求数据resovle，或者抛出一个错误。\n"
  },
  "runPromisesInSeries": {
    "prefix": "30s_runPromisesInSeries",
    "body": [
      "const runPromisesInSeries = ps => ps.reduce((p, next) => p.then(next), Promise.resolve());"
    ],
    "description": "Runs an array of promises in series.\n\n按顺序执行一个promise的数组。\n\nUse `Array.prototype.reduce()` to create a promise chain, where each promise returns the next promise when resolved.\n\n使用`Array.prototype.reduce()`来创建一个每个prosmise解决后返回下一个promise的promise链。\n"
  },
  "sample": {
    "prefix": "30s_sample",
    "body": [
      "const sample = arr => arr[Math.floor(Math.random() * arr.length)];"
    ],
    "description": "Returns a random element from an array.\n\n从数组中返回一个随机元素。\n\nUse `Math.random()` to generate a random number, multiply it by `length` and round it off to the nearest whole number using `Math.floor()`.\nThis method also works with strings.\n\n使用`Math.random()`生成一个随机数，把它乘以数组长度 `length`，并使用`Math.floor()`来取得不大于相乘结果的最接近整数。这个方法也适用于字符串。\n"
  },
  "sampleSize": {
    "prefix": "30s_sampleSize",
    "body": [
      "const sampleSize = ([...arr], n = 1) => {",
      "  let m = arr.length;",
      "  while (m) {",
      "    const i = Math.floor(Math.random() * m--);",
      "    [arr[m], arr[i]] = [arr[i], arr[m]];",
      "  }",
      "  return arr.slice(0, n);",
      "};"
    ],
    "description": "Gets `n` random elements at unique keys from `array` up to the size of `array`.\n\n从数组`array`中随机的不重复的获取最多`n` 个元素（`array`的长度个）。\n\nShuffle the array using the [Fisher-Yates algorithm](https://github.com/30-seconds/30-seconds-of-code#shuffle).\nUse `Array.prototype.slice()` to get the first `n` elements.\nOmit the second argument, `n` to get only one element at random from the array.\n\n使用Fisher-Yates算法[Fisher-Yates algorithm](https://github.com/30-seconds/30-seconds-of-code#shuffle)来对数组洗牌。使用`Array.prototype.slice()`来获取前`n`个元素。如果第二个元素`n`不传，则只随机的从数组中获取一个元素。\n"
  },
  "scrollToTop": {
    "prefix": "30s_scrollToTop",
    "body": [
      "const scrollToTop = () => {",
      "  const c = document.documentElement.scrollTop || document.body.scrollTop;",
      "  if (c > 0) {",
      "    window.requestAnimationFrame(scrollToTop);",
      "    window.scrollTo(0, c - c / 8);",
      "  }",
      "};"
    ],
    "description": "Smooth-scrolls to the top of the page.\n\n平滑的滑动到页面顶部。\n\nGet distance from top using `document.documentElement.scrollTop` or `document.body.scrollTop`.\nScroll by a fraction of the distance from the top. Use `window.requestAnimationFrame()` to animate the scrolling.\n\n使用`document.documentElement.scrollTop`或者`document.body.scrollTop`获取到顶部的距离。从顶部滚动一部分距离。使用`window.requestAnimationFrame()`来执行滚动操作。\n"
  },
  "sdbm": {
    "prefix": "30s_sdbm",
    "body": [
      "const sdbm = str => {",
      "  let arr = str.split('');",
      "  return arr.reduce(",
      "    (hashCode, currentVal) =>",
      "      (hashCode = currentVal.charCodeAt(0) + (hashCode << 6) + (hashCode << 16) - hashCode),",
      "    0",
      "  );",
      "};"
    ],
    "description": "Hashes the input string into a whole number.\n\n把输入hash成一个完整数字。\n\nUse `String.prototype.split('')` and `Array.prototype.reduce()` to create a hash of the input string, utilizing bit shifting.\n\n使用`String.prototype.split('')`和`Array.prototype.reduce()`来创建一个输入字符串的hash，使用位移操作。\n"
  },
  "serializeCookie": {
    "prefix": "30s_serializeCookie",
    "body": [
      "const serializeCookie = (name, val) => `${encodeURIComponent(name)}=${encodeURIComponent(val)}`;"
    ],
    "description": "Serialize a cookie name-value pair into a Set-Cookie header string.\n\n把一个cookie键值对序列化为一个Set-Cookie HTTP头字符串。\n\nUse template literals and `encodeURIComponent()` to create the appropriate string.\n\n使用模板字面量和`encodeURIComponent()`来创建一个合适的字符串。\n"
  },
  "serializeForm": {
    "prefix": "30s_serializeForm",
    "body": [
      "const serializeForm = form =>",
      "  Array.from(new FormData(form), field => field.map(encodeURIComponent).join('=')).join('&');"
    ],
    "description": "Encode a set of form elements as a query string.\n\nUse the `FormData` constructor to convert the HTML `form` to `FormData`, `Array.from()` to convert to an array, passing a map function as the second argument.\nUse `Array.prototype.map()` and `window.encodeURIComponent()` to encode each field's value.\nUse `Array.prototype.join()` with appropriate argumens to produce an appropriate query string.\n"
  },
  "setStyle": {
    "prefix": "30s_setStyle",
    "body": [
      "const setStyle = (el, ruleName, val) => (el.style[ruleName] = val);"
    ],
    "description": "Sets the value of a CSS rule for the specified element.\n\n为指定的元素设置CSS规则值。\n\nUse `element.style` to set the value of the CSS rule for the specified element to `val`.\n\n使用`element.style`来把指定元素的CSS值设置为`val`。\n"
  },
  "shallowClone": {
    "prefix": "30s_shallowClone",
    "body": [
      "const shallowClone = obj => Object.assign({}, obj);"
    ],
    "description": "Creates a shallow clone of an object.\n\n创建一个对象的浅拷贝。\n\nUse `Object.assign()` and an empty object (`{}`) to create a shallow clone of the original.\n\n使用`Object.assign()`和一个空对象来创建一个原始对象的浅拷贝。\n"
  },
  "shank": {
    "prefix": "30s_shank",
    "body": [
      "const shank = (arr, index = 0, delCount = 0, ...elements) =>",
      "  arr",
      "    .slice(0, index)",
      "    .concat(elements)",
      "    .concat(arr.slice(index + delCount));"
    ],
    "description": "Has the same functionality as [`Array.prototype.splice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice), but returning a new array instead of mutating the original array.\n\n和[`Array.prototype.splice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)有相同的作用，但返回一个新数组，不改变原始数组。\n\nUse `Array.prototype.slice()` and `Array.prototype.concat()` to get a new array with the new contents after removing existing elements and/or adding new elements.\nOmit the second argument, `index`, to start at `0`.\nOmit the third argument, `delCount`, to remove `0` elements.\nOmit the fourth argument, `elements`, in order to not add any new elements.\n\n使用`Array.prototype.slice()`和`Array.prototype.concat()`来获取一个删除现有元素/或添加新元素后的新数组。如果不传第二个参数`index`，默认值为`0`；如果不传第三个参数`delCount`，默认值是`0`（不删除元素）；不传第四个参数`elements`，则不添加任何新元素。\n"
  },
  "show": {
    "prefix": "30s_show",
    "body": [
      "const show = (...el) => [...el].forEach(e => (e.style.display = ''));"
    ],
    "description": "Shows all the elements specified.\n\n显示所有指定的元素。\n\nUse the spread operator (`...`) and `Array.prototype.forEach()` to clear the `display` property for each element specified.\n\n使用展开操作符(`...`)和`Array.prototype.forEach()`来清除每个指定元素的`display`属性。\n"
  },
  "shuffle": {
    "prefix": "30s_shuffle",
    "body": [
      "const shuffle = ([...arr]) => {",
      "  let m = arr.length;",
      "  while (m) {",
      "    const i = Math.floor(Math.random() * m--);",
      "    [arr[m], arr[i]] = [arr[i], arr[m]];",
      "  }",
      "  return arr;",
      "};"
    ],
    "description": "Randomizes the order of the values of an array, returning a new array.\n\nUse the [Fisher-Yates algorithm](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Fisher_and_Yates'_original_method) to reorder the elements of the array.\n"
  },
  "similarity": {
    "prefix": "30s_similarity",
    "body": [
      "const similarity = (arr, values) => arr.filter(v => values.includes(v));"
    ],
    "description": "Returns an array of elements that appear in both arrays.\n\n返回出现在两个数组中的公共元素组成的数组。\n\nUse `Array.prototype.filter()` to remove values that are not part of `values`, determined using `Array.prototype.includes()`.\n\n使用`Array.prototype.filter()`来删除不在`values`中的元素（通过`Array.prototype.includes()`来判断是否存在）。\n"
  },
  "size": {
    "prefix": "30s_size",
    "body": [
      "const size = val =>",
      "  Array.isArray(val)",
      "    ? val.length",
      "    : val && typeof val === 'object'",
      "    ? val.size || val.length || Object.keys(val).length",
      "    : typeof val === 'string'",
      "    ? new Blob([val]).size",
      "    : 0;"
    ],
    "description": "Gets the size of an array, object or string.\n\nGet type of `val` (`array`, `object` or `string`). \nUse `length` property for arrays.\nUse `length` or `size` value if available or number of keys for objects.\nUse `size` of a [`Blob` object](https://developer.mozilla.org/en-US/docs/Web/API/Blob) created from `val` for strings.\nSplit strings into array of characters with `split('')` and return its length.\n"
  },
  "sleep": {
    "prefix": "30s_sleep",
    "body": [
      "const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));"
    ],
    "description": "Delays the execution of an asynchronous function.\n\n延迟一个异步函数的执行。\n\nDelay executing part of an `async` function, by putting it to sleep, returning a `Promise`.\n\n通过把`async`函数放到sleep后，延迟它的部分执行，返回一个`Promise`。\n"
  },
  "smoothScroll": {
    "prefix": "30s_smoothScroll",
    "body": [
      "const smoothScroll = element =>",
      "  document.querySelector(element).scrollIntoView({",
      "    behavior: 'smooth'",
      "  });"
    ],
    "description": "Smoothly scrolls the element on which it's called into the visible area of the browser window.\n\n把指定元素滚动到它所调用的浏览器窗口的可见区域内。\n\nUse `.scrollIntoView` method to scroll the element. \nPass `{ behavior: 'smooth' }` to `.scrollIntoView` so it scrolls smoothly.\n\n使用`.scrollIntoView`方法来滚动元素。把`{ behavior: 'smooth' }`传给`.scrollIntoView`，所以滚动是平滑的。\n"
  },
  "sortCharactersInString": {
    "prefix": "30s_sortCharactersInString",
    "body": [
      "const sortCharactersInString = str => [...str].sort((a, b) => a.localeCompare(b)).join('');"
    ],
    "description": "Alphabetically sorts the characters in a string.\n\n按字母序排序一个字符串中的字符。\n\nUse the spread operator (`...`), `Array.prototype.sort()` and  `String.localeCompare()` to sort the characters in `str`, recombine using `String.prototype.join('')`.\n\n使用展开操作符(`...`), `Array.prototype.sort()`和`String.localeCompare()`来排序`str`的字符，使用`String.prototype.join('')`重新结合它们。\n"
  },
  "sortedIndex": {
    "prefix": "30s_sortedIndex",
    "body": [
      "const sortedIndex = (arr, n) => {",
      "  const isDescending = arr[0] > arr[arr.length - 1];",
      "  const index = arr.findIndex(el => (isDescending ? n >= el : n <= el));",
      "  return index === -1 ? arr.length : index;",
      "};"
    ],
    "description": "Returns the lowest index at which value should be inserted into array in order to maintain its sort order.\n\n返回为了维持原始有序数组的顺序，把给定的新元素值添加到数组中的最小位置。\n\nCheck if the array is sorted in descending order (loosely).\nUse `Array.prototype.findIndex()` to find the appropriate index where the element should be inserted.\n\n检查数组是否被倒序排列（非严格的）。使用`Array.prototype.findIndex()`来找到插入新元素的合适位置。\n"
  },
  "sortedIndexBy": {
    "prefix": "30s_sortedIndexBy",
    "body": [
      "const sortedIndexBy = (arr, n, fn) => {",
      "  const isDescending = fn(arr[0]) > fn(arr[arr.length - 1]);",
      "  const val = fn(n);",
      "  const index = arr.findIndex(el => (isDescending ? val >= fn(el) : val <= fn(el)));",
      "  return index === -1 ? arr.length : index;",
      "};"
    ],
    "description": "Returns the lowest index at which value should be inserted into array in order to maintain its sort order, based on a provided iterator function.\n\n基于给定的遍历函数，返回为了维持原始有序数组的顺序，把给定的新元素值添加到数组中的最小位置。\n\nCheck if the array is sorted in descending order (loosely).\nUse `Array.prototype.findIndex()` to find the appropriate index where the element should be inserted, based on the iterator function `fn`.\n\n检查数组是否被倒序排列（非严格的）。使用`Array.prototype.findIndex()`来基于遍历函数`fn`的结找到插入新元素的合适位置。\n"
  },
  "sortedLastIndex": {
    "prefix": "30s_sortedLastIndex",
    "body": [
      "const sortedLastIndex = (arr, n) => {",
      "  const isDescending = arr[0] > arr[arr.length - 1];",
      "  const index = arr.reverse().findIndex(el => (isDescending ? n <= el : n >= el));",
      "  return index === -1 ? 0 : arr.length - index;",
      "};"
    ],
    "description": "Returns the highest index at which value should be inserted into array in order to maintain its sort order.\n\n返回为了维持原始有序数组的顺序，把给定的新元素值添加到数组中的最大位置。\n\nCheck if the array is sorted in descending order (loosely).\nUse `Array.prototype.reverse()` and `Array.prototype.findIndex()` to find the appropriate last index where the element should be inserted.\n\n检查数组是否被倒序排列（非严格的）。使用`Array.prototype.reverse()`和`Array.prototype.findIndex()`来找到插入新元素的合适位置。\n"
  },
  "sortedLastIndexBy": {
    "prefix": "30s_sortedLastIndexBy",
    "body": [
      "const sortedLastIndexBy = (arr, n, fn) => {",
      "  const isDescending = fn(arr[0]) > fn(arr[arr.length - 1]);",
      "  const val = fn(n);",
      "  const index = arr",
      "    .map(fn)",
      "    .reverse()",
      "    .findIndex(el => (isDescending ? val <= el : val >= el));",
      "  return index === -1 ? 0 : arr.length - index;",
      "};"
    ],
    "description": "Returns the highest index at which value should be inserted into array in order to maintain its sort order, based on a provided iterator function.\n\n基于给定的遍历函数，返回为了维持原始有序数组的顺序，把给定的新元素值添加到数组中的最大位置。\n\nCheck if the array is sorted in descending order (loosely).\nUse `Array.prototype.map()` to apply the iterator function to all elements of the array.\nUse `Array.prototype.reverse()` and `Array.prototype.findIndex()` to find the appropriate last index where the element should be inserted, based on the provided iterator function.\n\n检查数组是否被倒序排列（非严格的）。使用`Array.prototype.map()`来对所有的元素应用遍历函数。使用`Array.prototype.reverse()`和`Array.prototype.findIndex()`来基于遍历函数`fn`的结果找到插入新元素的合适位置。\n"
  },
  "splitLines": {
    "prefix": "30s_splitLines",
    "body": [
      "const splitLines = str => str.split(/\\r?\\n/);"
    ],
    "description": "Splits a multiline string into an array of lines.\n\n把多行字符拆分成行的数组。\n\nUse `String.prototype.split()` and a regular expression to match line breaks and create an array.\n\n使用`String.prototype.split()`和一个匹配换行的正则表达式来并创建一个数组。\n"
  },
  "spreadOver": {
    "prefix": "30s_spreadOver",
    "body": [
      "const spreadOver = fn => argsArr => fn(...argsArr);"
    ],
    "description": "Takes a variadic function and returns a closure that accepts an array of arguments to map to the inputs of the function.\n\n传入一个可变的函数，返回一个闭包，它接受参数数组来代替原本的输入。\n\nUse closures and the spread operator (`...`) to map the array of arguments to the inputs of the function.\n\n使用闭包和展开操作符(`...`)来把参数数组映射给函数输入。\n"
  },
  "stableSort": {
    "prefix": "30s_stableSort",
    "body": [
      "const stableSort = (arr, compare) =>",
      "  arr",
      "    .map((item, index) => ({ item, index }))",
      "    .sort((a, b) => compare(a.item, b.item) || a.index - b.index)",
      "    .map(({ item }) => item);"
    ],
    "description": "Performs stable sorting of an array, preserving the initial indexes of items when their values are the same.\nDoes not mutate the original array, but returns a new array instead.\n\n按照数组的固定顺序排序，如果值相同，维持元素的原始序号不变。不直接改变原始数组，而是返回一个新数组。\n\nUse `Array.prototype.map()` to pair each element of the input array with its corresponding index.\nUse `Array.prototype.sort()` and a `compare` function to sort the list, preserving their initial order if the items compared are equal.\nUse `Array.prototype.map()` to convert back to the initial array items.\n\n使用`Array.prototype.map()`构造每个输入数组的元素的值和它的序号的数值对。使用`Array.prototype.sort()`和一个`compare`函数来对列表排序，如果比较结果相等则维持它们的初始序号。使用`Array.prototype.map()`把数值对还原成原始的数值元素。(个人认为：当前的JavaScript的sort方法本身就是稳定排序，应该只需要拷贝个新数组就可以了)。\n"
  },
  "standardDeviation": {
    "prefix": "30s_standardDeviation",
    "body": [
      "const standardDeviation = (arr, usePopulation = false) => {",
      "  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;",
      "  return Math.sqrt(",
      "    arr.reduce((acc, val) => acc.concat((val - mean) ** 2), []).reduce((acc, val) => acc + val, 0) /",
      "      (arr.length - (usePopulation ? 0 : 1))",
      "  );",
      "};"
    ],
    "description": "Returns the standard deviation of an array of numbers.\n\n返回一个数字数组的标准差。\n\nUse `Array.prototype.reduce()` to calculate the mean, variance and the sum of the variance of the values, the variance of the values, then\ndetermine the standard deviation.\nYou can omit the second argument to get the sample standard deviation or set it to `true` to get the population standard deviation.\n\n使用`Array.prototype.reduce()`来计算平均值，方差和所有值的方差和还有整体方差，然后计算出标准差。你可以不传第二个参数来获得样本标准差，如果把它设置为`true`则获取总体标准差。\n"
  },
  "stringPermutations": {
    "prefix": "30s_stringPermutations",
    "body": [
      "const stringPermutations = str => {",
      "  if (str.length <= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];",
      "  return str",
      "    .split('')",
      "    .reduce(",
      "      (acc, letter, i) =>",
      "        acc.concat(stringPermutations(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)),",
      "      []",
      "    );",
      "};"
    ],
    "description": "Generates all permutations of a string (contains duplicates).\n\n生成一个字符串的所有排列（包括重复的）。\n\n⚠️ **WARNING**: This function's execution time increases exponentially with each character. Anything more than 8 to 10 characters will cause your browser to hang as it tries to solve all the different combinations.\n\n⚠️ **WARNING**: 这个函数的执行时间随每个字符指数级增长。每个超过8到10个字符的字符串将因为尝试所有不同的组合而导致你的浏览器挂起（无响应）。\n\nUse recursion.\nFor each letter in the given string, create all the partial permutations for the rest of its letters.\nUse `Array.prototype.map()` to combine the letter with each partial permutation, then `Array.prototype.reduce()` to combine all permutations in one array.\nBase cases are for string `length` equal to `2` or `1`.\n\n使用递归。对给定字符串中的每个字母，创建剩余字母的所有的部分全排列。使用`Array.prototype.map()`来把这个字母和每个部分全排列组装起来，然后使用`Array.prototype.reduce()`把所有排列组装到一个数组中。基本的场景是字符串`length`等于`2`或`1`。\n"
  },
  "stripHTMLTags": {
    "prefix": "30s_stripHTMLTags",
    "body": [
      "const stripHTMLTags = str => str.replace(/<[^>]*>/g, '');"
    ],
    "description": "Removes HTML/XML tags from string.\n\n删除字符串中的HTML/XML标签。\n\nUse a regular expression to remove HTML/XML tags from a string.\n\n使用正则表达式来删除一个字符串中的HTML/XML标签。\n"
  },
  "sum": {
    "prefix": "30s_sum",
    "body": [
      "const sum = (...arr) => [...arr].reduce((acc, val) => acc + val, 0);"
    ],
    "description": "Returns the sum of two or more numbers/arrays.\n\n返回两个或更多数字列表或者数组列表的和。\n\nUse `Array.prototype.reduce()` to add each value to an accumulator, initialized with a value of `0`.\n\n使用`Array.prototype.reduce()`来把每个值累加，初始累加值为0。\n"
  },
  "sumBy": {
    "prefix": "30s_sumBy",
    "body": [
      "const sumBy = (arr, fn) =>",
      "  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => acc + val, 0);"
    ],
    "description": "Returns the sum of an array, after mapping each element to a value using the provided function.\n\n在把每个元素应用提供的函数后，返回一个数组的和。\n\nUse `Array.prototype.map()` to map each element to the value returned by `fn`, `Array.prototype.reduce()` to add each value to an accumulator, initialized with a value of `0`.\n\n使用`Array.prototype.map()`来把每个元素映射到应用`fn`的返回值，使用`Array.prototype.reduce()`来把每个值累加，初始累加值为0。\n"
  },
  "sumPower": {
    "prefix": "30s_sumPower",
    "body": [
      "const sumPower = (end, power = 2, start = 1) =>",
      "  Array(end + 1 - start)",
      "    .fill(0)",
      "    .map((x, i) => (i + start) ** power)",
      "    .reduce((a, b) => a + b, 0);"
    ],
    "description": "Returns the sum of the powers of all the numbers from `start` to `end` (both inclusive).\n\n返回从`start`到`end`（两边都闭区间）的所有数字的加权和。\n\nUse `Array.prototype.fill()` to create an array of all the numbers in the target range, `Array.prototype.map()` and the exponent operator (`**`) to raise them to `power` and `Array.prototype.reduce()` to add them together.\nOmit the second argument, `power`, to use a default power of `2`.\nOmit the third argument, `start`, to use a default starting value of `1`.\n\n使用`Array.prototype.fill()`来创建一个在目标范围内的所有数字的数组，使用`Array.prototype.map()`和求幂操作符(`**`) 来把它们加权到`power`并用`Array.prototype.reduce()`把结果加和起来。如果不传第二个参数`power`，默认值权重为`2`；如果不传第三个参数`start`，默认从`1`开始。\n"
  },
  "symmetricDifference": {
    "prefix": "30s_symmetricDifference",
    "body": [
      "const symmetricDifference = (a, b) => {",
      "  const sA = new Set(a),",
      "    sB = new Set(b);",
      "  return [...a.filter(x => !sB.has(x)), ...b.filter(x => !sA.has(x))];",
      "};"
    ],
    "description": "Returns the symmetric difference between two arrays, without filtering out duplicate values.\n\n不过滤掉重复元素，返回两个数组中全部的差异（每个数组中不存在在对方中的元素合集）。\n\nCreate a `Set` from each array, then use `Array.prototype.filter()` on each of them to only keep values not contained in the other.\n\n从给定的两个数组创建一个`Set`，然后对它们分别使用`Array.prototype.filter()`来只保留不包含在另一个数组中的元素。\n"
  },
  "symmetricDifferenceBy": {
    "prefix": "30s_symmetricDifferenceBy",
    "body": [
      "const symmetricDifferenceBy = (a, b, fn) => {",
      "  const sA = new Set(a.map(v => fn(v))),",
      "    sB = new Set(b.map(v => fn(v)));",
      "  return [...a.filter(x => !sB.has(fn(x))), ...b.filter(x => !sA.has(fn(x)))];",
      "};"
    ],
    "description": "Returns the symmetric difference between two arrays, after applying the provided function to each array element of both.\n\n基于给定的比较函数，不过滤掉重复元素，返回两个数组中全部的差异（每个数组中不存在在对方中的元素合集）。\n\nCreate a `Set` by applying `fn` to each array's elements, then use `Array.prototype.filter()` on each of them to only keep values not contained in the other.\n\n对给定的两个数组元素应用`fn`后创建一个结果的`Set`，然后对它们分别使用`Array.prototype.filter()`来只保留不包含在另一个数组的结果中的元素。\n"
  },
  "symmetricDifferenceWith": {
    "prefix": "30s_symmetricDifferenceWith",
    "body": [
      "const symmetricDifferenceWith = (arr, val, comp) => [",
      "  ...arr.filter(a => val.findIndex(b => comp(a, b)) === -1),",
      "  ...val.filter(a => arr.findIndex(b => comp(a, b)) === -1)",
      "];"
    ],
    "description": "Returns the symmetric difference between two arrays, using a provided function as a comparator.\n\n使用给定的函数作为比较器，返回两个数组中全部的差异（每个数组中不存在在对方中的元素合集）。\n\nUse `Array.prototype.filter()` and `Array.prototype.findIndex()` to find the appropriate values.\n\n使用`Array.prototype.filter()` 和 `Array.prototype.findIndex()`来找到合适的元素。\n"
  },
  "tail": {
    "prefix": "30s_tail",
    "body": [
      "const tail = arr => (arr.length > 1 ? arr.slice(1) : arr);"
    ],
    "description": "Returns all elements in an array except for the first one.\n\n返回数组中除了第一个元素外的其他元素。\n\nReturn `Array.prototype.slice(1)` if the array's `length` is more than `1`, otherwise, return the whole array.\n\n如果数组长度大于`1`，返回 `Array.prototype.slice(1)`；否则返回整个数组。\n"
  },
  "take": {
    "prefix": "30s_take",
    "body": [
      "const take = (arr, n = 1) => arr.slice(0, n);"
    ],
    "description": "Returns an array with n elements removed from the beginning.\n\n返回一个由头部`n`个元素构成的数组。\n\nUse `Array.prototype.slice()` to create a slice of the array with `n` elements taken from the beginning.\n\n使用`Array.prototype.slice()`来用头部的`n`个元素创建一个数组的切片。\n"
  },
  "takeRight": {
    "prefix": "30s_takeRight",
    "body": [
      "const takeRight = (arr, n = 1) => arr.slice(arr.length - n, arr.length);"
    ],
    "description": "Returns an array with n elements removed from the end.\n\n返回一个由尾部`n`个元素构成的数组。\n\nUse `Array.prototype.slice()` to create a slice of the array with `n` elements taken from the end.\n\n使用`Array.prototype.slice()`来用尾部的`n`个元素创建一个数组的切片。\n"
  },
  "takeRightWhile": {
    "prefix": "30s_takeRightWhile",
    "body": [
      "const takeRightWhile = (arr, func) =>",
      "  arr.reduceRight((acc, el) => (func(el) ? acc : [el, ...acc]), []);"
    ],
    "description": "Removes elements from the end of an array until the passed function returns `true`. Returns the removed elements.\n\n删除直到传入的函数返回`true`之前的所有数组尾部元素（代码应该实现的是：从尾部开始计算，按照原顺序返回应用函数后返回假值的元素）。返回删除掉的元素列表。\n\nLoop through the array, using a `Array.prototype.reduceRight()` and accumulating elements while the function returns falsy value.\n\n遍历数组，使用`Array.prototype.reduceRight()`来收集返回假值的元素列表。\n"
  },
  "takeWhile": {
    "prefix": "30s_takeWhile",
    "body": [
      "const takeWhile = (arr, func) => {",
      "  for (const [i, val] of arr.entries()) if (func(val)) return arr.slice(0, i);",
      "  return arr;",
      "};"
    ],
    "description": "Removes elements in an array until the passed function returns `true`. Returns the removed elements.\n\n删除直到传入的函数返回`true`之前的所有数组首部元素。返回删除掉的元素列表。\n\nLoop through the array, using a `for...of` loop over `Array.prototype.entries()` until the returned value from the function is `true`.\nReturn the removed elements, using `Array.prototype.slice()`.\n\n遍历数组，使用`for...of`遍历`Array.prototype.entries()`的结果，直到函数返回值为`true`。使用`Array.prototype.slice()`返回删除掉的元素。\n"
  },
  "throttle": {
    "prefix": "30s_throttle",
    "body": [
      "const throttle = (fn, wait) => {",
      "  let inThrottle, lastFn, lastTime;",
      "  return function() {",
      "    const context = this,",
      "      args = arguments;",
      "    if (!inThrottle) {",
      "      fn.apply(context, args);",
      "      lastTime = Date.now();",
      "      inThrottle = true;",
      "    } else {",
      "      clearTimeout(lastFn);",
      "      lastFn = setTimeout(function() {",
      "        if (Date.now() - lastTime >= wait) {",
      "          fn.apply(context, args);",
      "          lastTime = Date.now();",
      "        }",
      "      }, Math.max(wait - (Date.now() - lastTime), 0));",
      "    }",
      "  };",
      "};"
    ],
    "description": "Creates a throttled function that only invokes the provided function at most once per every `wait` milliseconds\n\n创建一个每`wait`毫秒中最多执行给定的函数一次的节流函数。\n\nUse `setTimeout()` and `clearTimeout()` to throttle the given method, `fn`.\nUse `Function.prototype.apply()` to apply the `this` context to the function and provide the necessary `arguments`.\nUse `Date.now()` to keep track of the last time the throttled function was invoked.\nOmit the second argument, `wait`, to set the timeout at a default of 0 ms.\n\n使用`setTimeout()`和`clearTimeout()`来节制给定的方法`fn`。使用`Function.prototype.apply()`把`this`上下文应用到这个函数并提供必要的`arguments`。使用`Date.now()`来记录被节流的函数的上一次执行时间。如果不传第二个参数`wait`，则把timeout(时间间隔)设置为默认的0ms。\n"
  },
  "times": {
    "prefix": "30s_times",
    "body": [
      "const times = (n, fn, context = undefined) => {",
      "  let i = 0;",
      "  while (fn.call(context, i) !== false && ++i < n) {}",
      "};"
    ],
    "description": "Iterates over a callback `n` times\n\n循环一个回调函数`n`次。\n\nUse `Function.call()` to call `fn` `n` times or until it returns `false`.\nOmit the last argument, `context`, to use an `undefined` object (or the global object in non-strict mode).\n\n使用`Function.call()`来调用`fn`函数`n`次或者直到它返回`false`。如果不传最后一个参数`context`，则使用一个`undefined`对象（在non-strict模式下使用全局对象）。\n"
  },
  "timeTaken": {
    "prefix": "30s_timeTaken",
    "body": [
      "const timeTaken = callback => {",
      "  console.time('timeTaken');",
      "  const r = callback();",
      "  console.timeEnd('timeTaken');",
      "  return r;",
      "};"
    ],
    "description": "Measures the time taken by a function to execute.\n\n测量函数执行所花费的时间。\n\nUse `console.time()` and `console.timeEnd()` to measure the difference between the start and end times to determine how long the callback took to execute.\n\n使用`console.time()`和`console.timeEnd()`来测量开始和结束时间的差值来确定函数花费了多少时间来执行。\n"
  },
  "toCamelCase": {
    "prefix": "30s_toCamelCase",
    "body": [
      "const toCamelCase = str => {",
      "  let s =",
      "    str &&",
      "    str",
      "      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)",
      "      .map(x => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase())",
      "      .join('');",
      "  return s.slice(0, 1).toLowerCase() + s.slice(1);",
      "};"
    ],
    "description": "Converts a string to camelcase.\n\n把字符串转换为驼峰形式。\n\nBreak the string into words and combine them capitalizing the first letter of each word, using a regexp.\n\n使用正则表达式把字符串拆分为单词列表，并在大写化每个词的首字母后合并它们。\n"
  },
  "toCurrency": {
    "prefix": "30s_toCurrency",
    "body": [
      "const toCurrency = (n, curr, LanguageFormat = undefined) =>",
      "  Intl.NumberFormat(LanguageFormat, { style: 'currency', currency: curr }).format(n);"
    ],
    "description": "Take a number and return specified currency formatting.\n\n接受一个数字，返回指定的货币化格式。\n\nUse `Intl.NumberFormat` to enable country / currency sensitive formatting.\n\n使用`Intl.NumberFormat`来打开国家/货币（country / currenc）敏感格式。\n"
  },
  "toDecimalMark": {
    "prefix": "30s_toDecimalMark",
    "body": [
      "const toDecimalMark = num => num.toLocaleString('en-US');"
    ],
    "description": "Use `toLocaleString()` to convert a float-point arithmetic to the [Decimal mark](https://en.wikipedia.org/wiki/Decimal_mark) form. It makes a comma separated string from a number.\n\n使用`toLocaleString()`来把一个浮点数转换为[Decimal mark](https://en.wikipedia.org/wiki/Decimal_mark)格式。它从数字创建一个用逗号分隔的字符串。\n\n"
  },
  "toggleClass": {
    "prefix": "30s_toggleClass",
    "body": [
      "const toggleClass = (el, className) => el.classList.toggle(className);"
    ],
    "description": "Toggle a class for an element.\n\n开关一个元素的class。\n\nUse `element.classList.toggle()` to toggle the specified class for the element.\n\n使用`element.classList.toggle()`来开关指定元素的class。\n"
  },
  "toHash": {
    "prefix": "30s_toHash",
    "body": [
      "const toHash = (object, key) =>",
      "  Array.prototype.reduce.call(",
      "    object,",
      "    (acc, data, index) => ((acc[!key ? index : data[key]] = data), acc),",
      "    {}",
      "  );"
    ],
    "description": "Reduces a given Array-like into a value hash (keyed data store).\n\n把给定的Array-like转换为一个hash对象（有键值的数据存储形式）。\n\nGiven an Iterable or Array-like structure, call `Array.prototype.reduce.call()` on the provided object to step over it and return an Object, keyed by the reference value.\n\n给定Iterable或者Array-like结构，对给定的对象使用`Array.prototype.reduce.call()`来遍历它，并返回一个用引用的值作为键值的对象。\n"
  },
  "toKebabCase": {
    "prefix": "30s_toKebabCase",
    "body": [
      "const toKebabCase = str =>",
      "  str &&",
      "  str",
      "    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)",
      "    .map(x => x.toLowerCase())",
      "    .join('-');"
    ],
    "description": "Converts a string to kebab case.\n\n把字符串转换为中划线形式。\n\nBreak the string into words and combine them adding `-` as a separator, using a regexp.\n\n使用正则表达式把字符串拆分为单词列表，并在添加`-`作为分隔符后合并它们。\n"
  },
  "tomorrow": {
    "prefix": "30s_tomorrow",
    "body": [
      "const tomorrow = () => {",
      "  let t = new Date();",
      "  t.setDate(t.getDate() + 1);",
      "  return t.toISOString().split('T')[0];",
      "};"
    ],
    "description": "Results in a string representation of tomorrow's date.\n\n返回一个代表明天日期的字符串。\n\nUse `new Date()` to get the current date, increment by one using `Date.getDate()` and set the value to the result using `Date.setDate()`. \nUse `Date.prototype.toISOString()` to return a string in `yyyy-mm-dd` format.\n\n使用`new Date()`来获取今天的日期，使用`Date.getDate()`和`Date.setDate()`设置值来把日期增加一天。使用`Date.prototype.toISOString()`返回`yyyy-mm-dd`格式的字符串。\n"
  },
  "toOrdinalSuffix": {
    "prefix": "30s_toOrdinalSuffix",
    "body": [
      "const toOrdinalSuffix = num => {",
      "  const int = parseInt(num),",
      "    digits = [int % 10, int % 100],",
      "    ordinals = ['st', 'nd', 'rd', 'th'],",
      "    oPattern = [1, 2, 3, 4],",
      "    tPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19];",
      "  return oPattern.includes(digits[0]) && !tPattern.includes(digits[1])",
      "    ? int + ordinals[digits[0] - 1]",
      "    : int + ordinals[3];",
      "};"
    ],
    "description": "Adds an ordinal suffix to a number.\n\n给一个数字添加一个序数后缀。\n\nUse the modulo operator (`%`) to find values of single and tens digits.\nFind which ordinal pattern digits match.\nIf digit is found in teens pattern, use teens ordinal.\n\n使用取模操作符(`%`)来找到个位和十位。找到它匹配哪个序数标识。如果某一位在十位数标志中找到，则使用十位数序数后缀。\n"
  },
  "toSafeInteger": {
    "prefix": "30s_toSafeInteger",
    "body": [
      "const toSafeInteger = num =>",
      "  Math.round(Math.max(Math.min(num, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER));"
    ],
    "description": "Converts a value to a safe integer.\n\n把一个值转换为安全整数。\n\nUse `Math.max()` and `Math.min()` to find the closest safe value.\nUse `Math.round()` to convert to an integer.\n\n使用`Math.max()`和`Math.min()`来找到最近的安全值。使用`Math.round()`把它转换为一个整数。\n"
  },
  "toSnakeCase": {
    "prefix": "30s_toSnakeCase",
    "body": [
      "const toSnakeCase = str =>",
      "  str &&",
      "  str",
      "    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)",
      "    .map(x => x.toLowerCase())",
      "    .join('_');"
    ],
    "description": "Converts a string to snake case.\n\n把字符串转换为下划线形式。\n\nBreak the string into words and combine them adding `_` as a separator, using a regexp.\n\n使用正则表达式把字符串拆分为单词列表，并在添加`_`作为分隔符后合并它们。\n"
  },
  "toTitleCase": {
    "prefix": "30s_toTitleCase",
    "body": [
      "const toTitleCase = str =>",
      "  str",
      "    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)",
      "    .map(x => x.charAt(0).toUpperCase() + x.slice(1))",
      "    .join(' ');"
    ],
    "description": "Converts a string to title case.\n\n把字符串转换为标题形式（首字母大写，用空格做分隔）。\n\nBreak the string into words, using a regexp, and combine them capitalizing the first letter of each word and adding a whitespace between them.\n\n使用正则表达式把字符串拆分为单词列表，并在大写化每个词的首字母和添加一个空格作为分隔符后合并它们。\n"
  },
  "transform": {
    "prefix": "30s_transform",
    "body": [
      "const transform = (obj, fn, acc) => Object.keys(obj).reduce((a, k) => fn(a, obj[k], k, obj), acc);"
    ],
    "description": "Applies a function against an accumulator and each key in the object (from left to right).\n\n对一个累加器和一个对象中每个键应用一个函数（从左到右）。\n\nUse `Object.keys(obj)` to iterate over each key in the object, `Array.prototype.reduce()` to call the apply the specified function against the given accumulator.\n\n使用`Object.keys(obj)`来遍历对象中每个键，`Array.prototype.reduce()`来对给出的累加器调用指定的函数（使用这个函数对对象中的键值进行累加操作）。\n"
  },
  "triggerEvent": {
    "prefix": "30s_triggerEvent",
    "body": [
      "const triggerEvent = (el, eventType, detail) =>",
      "  el.dispatchEvent(new CustomEvent(eventType, { detail }));"
    ],
    "description": "Triggers a specific event on a given element, optionally passing custom data.\n\n在给定的元素上触发指定事件，可选择传入自定义数据。\n\nUse `new CustomEvent()` to create an event from the specified `eventType` and details.\nUse `el.dispatchEvent()` to trigger the newly created event on the given element.\nOmit the third argument, `detail`, if you do not want to pass custom data to the triggered event.\n\n使用`new CustomEvent()`来创建一个指定`eventType`的事件和详细内容。使用`el.dispatchEvent()`在给定元素上触发这个新创建的事件。如果不需要传入自定义的数据到触发的事件，则不传第三个参数`detail`。\n"
  },
  "truncateString": {
    "prefix": "30s_truncateString",
    "body": [
      "const truncateString = (str, num) =>",
      "  str.length > num ? str.slice(0, num > 3 ? num - 3 : num) + '...' : str;"
    ],
    "description": "Truncates a string up to a specified length.\n\n把字符串截断到最多指定的长度。\n\nDetermine if the string's `length` is greater than `num`.\nReturn the string truncated to the desired length, with `'...'` appended to the end or the original string.\n\n判断字符串的`length`是否大于`num`。返回一个按指定长度截断并加上`'...'`后缀的字符串，或者原始的字符串。\n"
  },
  "truthCheckCollection": {
    "prefix": "30s_truthCheckCollection",
    "body": [
      "const truthCheckCollection = (collection, pre) => collection.every(obj => obj[pre]);"
    ],
    "description": "Checks if the predicate (second argument) is truthy on all elements of a collection (first argument).\n\n检查一个集合（第一个参数）中的所有元素的断言（第二个参数）是否为真值。\n\nUse `Array.prototype.every()` to check if each passed object has the specified property and if it returns a truthy value.\n\n使用`Array.prototype.every()`来检查是否传入的对象有指定的属性，并且它是否返回真值。\n"
  },
  "unary": {
    "prefix": "30s_unary",
    "body": [
      "const unary = fn => val => fn(val);"
    ],
    "description": "Creates a function that accepts up to one argument, ignoring any additional arguments.\n\n创建一个最多接受一个参数的函数，忽略其他参数。\n\nCall the provided function, `fn`, with just the first argument given.\n\n仅使用给出参数的第一个调用函数`fn`。\n"
  },
  "uncurry": {
    "prefix": "30s_uncurry",
    "body": [
      "const uncurry = (fn, n = 1) => (...args) => {",
      "  const next = acc => args => args.reduce((x, y) => x(y), acc);",
      "  if (n > args.length) throw new RangeError('Arguments too few!');",
      "  return next(fn)(args.slice(0, n));",
      "};"
    ],
    "description": "Uncurries a function up to depth `n`.\n\n去柯里化一个函数，最大处理深度为`n`。\n\nReturn a variadic function.\nUse `Array.prototype.reduce()` on the provided arguments to call each subsequent curry level of the function.\nIf the `length` of the provided arguments is less than `n` throw an error.\nOtherwise, call `fn` with the proper amount of arguments, using `Array.prototype.slice(0, n)`.\nOmit the second argument, `n`, to uncurry up to depth `1`.\n\n返回一个参数数目不确定的函数。对给定的参数列表使用`Array.prototype.reduce()`来调用这个函数的每个柯里化的层级。如果给定参数列表的`length`比`n`小则抛出异常。否则使用`Array.prototype.slice(0, n)`获取合适数目的参数列表来调用`fn`。如果不传第二个参数`n`，则最大去柯里化深度为`1`。\n"
  },
  "unescapeHTML": {
    "prefix": "30s_unescapeHTML",
    "body": [
      "const unescapeHTML = str =>",
      "  str.replace(",
      "    /&amp;|&lt;|&gt;|&#39;|&quot;/g,",
      "    tag =>",
      "      ({",
      "        '&amp;': '&',",
      "        '&lt;': '<',",
      "        '&gt;': '>',",
      "        '&#39;': \"'\",",
      "        '&quot;': '\"'",
      "      }[tag] || tag)",
      "  );"
    ],
    "description": "Unescapes escaped HTML characters.\n\n解析转义后的HTML字符列表。\n\nUse `String.prototype.replace()` with a regex that matches the characters that need to be unescaped, using a callback function to replace each escaped character instance with its associated unescaped character using a dictionary (object).\n\n使用`String.prototype.replace()`和匹配需要解析的字符的正则表达式，使用一个回调函数来用相应的解析后的字符替换每个转义后的字符实例，解析规则通过一个字典指定（object）。\n"
  },
  "unflattenObject": {
    "prefix": "30s_unflattenObject",
    "body": [
      "const unflattenObject = obj =>",
      "  Object.keys(obj).reduce((acc, k) => {",
      "    if (k.indexOf('.') !== -1) {",
      "      const keys = k.split('.');",
      "      Object.assign(",
      "        acc,",
      "        JSON.parse(",
      "          '{' +",
      "            keys.map((v, i) => (i !== keys.length - 1 ? `\"${v}\":{` : `\"${v}\":`)).join('') +",
      "            obj[k] +",
      "            '}'.repeat(keys.length)",
      "        )",
      "      );",
      "    } else acc[k] = obj[k];",
      "    return acc;",
      "  }, {});"
    ],
    "description": "Unflatten an object with the paths for keys.\n\n用键的路径列表去扁平化一个对象（变为多级结构）。\n\nUse `Object.keys(obj)` combined with `Array.prototype.reduce()` to convert flattened path node to a leaf node.\nIf the value of a key contains a dot delimiter (`.`), use `Array.prototype.split('.')`, string transformations and `JSON.parse()` to create an object, then `Object.assign()` to create the leaf node.\nOtherwise, add the appropriate key-value pair to the accumulator object.\n\n使用`Object.keys(obj)`结合`Array.prototype.reduce()`来把扁平的路径节点转换成一个叶子节点。如果键的值包含一个点分符合(`.`)，使用`Array.prototype.split('.')`，字符串变形和`JSON.parse()`来创建一个对象，然后用`Object.assign()`来创建一个叶子节点。否则，向累加器中添加合适的键值对。\n"
  },
  "unfold": {
    "prefix": "30s_unfold",
    "body": [
      "const unfold = (fn, seed) => {",
      "  let result = [],",
      "    val = [null, seed];",
      "  while ((val = fn(val[1]))) result.push(val[0]);",
      "  return result;",
      "};"
    ],
    "description": "Builds an array, using an iterator function and an initial seed value.\n\n使用一个遍历函数或者一个初始种子值来创建一个数组。\n\nUse a `while` loop and `Array.prototype.push()` to call the function repeatedly until it returns `false`.\nThe iterator function accepts one argument (`seed`) and must always return an array with two elements ([`value`, `nextSeed`]) or `false` to terminate.\n\n使用一个`while`循环和`Array.prototype.push()`来重复调用函数直到它返回`false`。这个遍历函数接收一个参数（`seed`）并且必须返回一个具有两个元素的数组（[`value`, `nextSeed`]）或者返回`false`来结束迭代。\n"
  },
  "union": {
    "prefix": "30s_union",
    "body": [
      "const union = (a, b) => Array.from(new Set([...a, ...b]));"
    ],
    "description": "Returns every element that exists in any of the two arrays once.\n\n返回两个数组中所有元素只出现一次所构成的数组（具有集合不重复的特性）。\n\nCreate a `Set` with all values of `a` and `b` and convert to an array.\n\n用所有的`a` 和 `b`内的元素创建一个`Set`并把它转为数组。\n"
  },
  "unionBy": {
    "prefix": "30s_unionBy",
    "body": [
      "const unionBy = (a, b, fn) => {",
      "  const s = new Set(a.map(fn));",
      "  return Array.from(new Set([...a, ...b.filter(x => !s.has(fn(x)))]));",
      "};"
    ],
    "description": "Returns every element that exists in any of the two arrays once, after applying the provided function to each array element of both.\n\n对两个数组中每个元素应用给定的函数后，返回所有结果中元素只出现一次所构成的数组（具有集合不重复的特性）。\n\nCreate a `Set` by applying all `fn` to all values of `a`.\nCreate a `Set` from `a` and all elements in `b` whose value, after applying `fn` does not match a value in the previously created set.\nReturn the last set converted to an array.\n\n用对`a`中所有值应用`fn`后的结果创建一个`Set`。用`a`和`b`中所有应用`fn`后结果不在之前的`Set`的元素创建另一`Set`。返回后一个`Set`转换为数组后的结果。\n"
  },
  "unionWith": {
    "prefix": "30s_unionWith",
    "body": [
      "const unionWith = (a, b, comp) =>",
      "  Array.from(new Set([...a, ...b.filter(x => a.findIndex(y => comp(x, y)) === -1)]));"
    ],
    "description": "Returns every element that exists in any of the two arrays once, using a provided comparator function.\n\n对两个数组中元素比较函数判断相等，返回不重复（判断相等的就视为重复）元素构成的数组（具有集合不重复的特性）。\n\nCreate a `Set` with all values of `a` and values in `b` for which the comparator finds no matches in `a`, using `Array.prototype.findIndex()`.\n\n用所有`a`中的值，加上用`Array.prototype.findIndex()`找到的`b`中使用比较函数判断后与`a`中元素不重复的元素创建一个`Set`。\n"
  },
  "uniqueElements": {
    "prefix": "30s_uniqueElements",
    "body": [
      "const uniqueElements = arr => [...new Set(arr)];"
    ],
    "description": "Returns all unique values of an array.\n\n返回数组中所有唯一的元素。\n\nUse ES6 `Set` and the `...rest` operator to discard all duplicated values.\n\n使用ES6的`Set`和`...rest`操作符来去除所有重复元素。\n"
  },
  "uniqueElementsBy": {
    "prefix": "30s_uniqueElementsBy",
    "body": [
      "const uniqueElementsBy = (arr, fn) =>",
      "  arr.reduce((acc, v) => {",
      "    if (!acc.some(x => fn(v, x))) acc.push(v);",
      "    return acc;",
      "  }, []);"
    ],
    "description": "Returns all unique values of an array, based on a provided comparator function.\n\n基于给定的比较函数判重，返回数组中所有唯一的元素。（使结果中有相同比较结果的元素唯一，只保留一个）\n\nUse `Array.prototype.reduce()` and `Array.prototype.some()` for an array containing only the first unique occurrence of each value, based on the comparator function, `fn`.\nThe comparator function takes two arguments: the values of the two elements being compared.\n\n使用`Array.prototype.reduce()`和`Array.prototype.some()`基于给定比较函数`fn`创建一个只包含每个值第一次出现的数组（每个值只包含一次）。比较函数有两个参数：分别是用来比较的两个值。\n"
  },
  "uniqueElementsByRight": {
    "prefix": "30s_uniqueElementsByRight",
    "body": [
      "const uniqueElementsByRight = (arr, fn) =>",
      "  arr.reduceRight((acc, v) => {",
      "    if (!acc.some(x => fn(v, x))) acc.push(v);",
      "    return acc;",
      "  }, []);"
    ],
    "description": "Returns all unique values of an array, based on a provided comparator function, starting from the right.\n\n从右侧开始，基于给定的比较函数判重，返回数组中所有唯一的值。（使结果中有相同比较结果的元素唯一，只保留一个）（只是计算顺序从后向前）\n\nUse `Array.prototype.reduceRight()` and `Array.prototype.some()` for an array containing only the last unique occurrence of each value, based on the comparator function, `fn`.\nThe comparator function takes two arguments: the values of the two elements being compared.\n\n使用`Array.prototype.reduceRight()`和`Array.prototype.some()`基于给定比较函数`fn`创建一个只包含每个值最后一次出现的数组（每个值只包含一次）。比较函数有两个参数：分别是用来比较的两个值。\n"
  },
  "uniqueSymmetricDifference": {
    "prefix": "30s_uniqueSymmetricDifference",
    "body": [
      "const uniqueSymmetricDifference = (a, b) => [",
      "  ...new Set([...a.filter(v => !b.includes(v)), ...b.filter(v => !a.includes(v))])",
      "];"
    ],
    "description": "Returns the unique symmetric difference between two arrays, not containing duplicate values from either array.\n\n返回两个数组中所有不相同的元素，不包含每个数组中的重复元素。\n\nUse `Array.prototype.filter()` and `Array.prototype.includes()` on each array to remove values contained in the other, then create a `Set` from the results, removing duplicate values.\n\n对每个数组使用`Array.prototype.filter()`和`Array.prototype.includes()`来删除存在在另一个数组中的元素，然后从剩下的结果中返回一个`Set`来去重。\n"
  },
  "untildify": {
    "prefix": "30s_untildify",
    "body": [
      "const untildify = str => str.replace(/^~($|\\/|\\\\)/, `${require('os').homedir()}$1`);"
    ],
    "description": "Converts a tilde path to an absolute path.\n\n把斜线路径（绝对）转换成相对路径。\n\nUse `String.prototype.replace()` with a regular expression and `OS.homedir()` to replace the `~` in the start of the path with the home directory.\n\n使用`String.prototype.replace()`和正则表达式，还有`OS.homedir()`来把路径开头的`~`替换为用户家目录。\n"
  },
  "unzip": {
    "prefix": "30s_unzip",
    "body": [
      "const unzip = arr =>",
      "  arr.reduce(",
      "    (acc, val) => (val.forEach((v, i) => acc[i].push(v)), acc),",
      "    Array.from({",
      "      length: Math.max(...arr.map(x => x.length))",
      "    }).map(x => [])",
      "  );"
    ],
    "description": "Creates an array of arrays, ungrouping the elements in an array produced by [zip](/js/s/zip).\n\nUse `Math.max.apply()` to get the longest subarray in the array, `Array.prototype.map()` to make each element an array.\nUse `Array.prototype.reduce()` and `Array.prototype.forEach()` to map grouped values to individual arrays.\n"
  },
  "unzipWith": {
    "prefix": "30s_unzipWith",
    "body": [
      "const unzipWith = (arr, fn) =>",
      "  arr",
      "    .reduce(",
      "      (acc, val) => (val.forEach((v, i) => acc[i].push(v)), acc),",
      "      Array.from({",
      "        length: Math.max(...arr.map(x => x.length))",
      "      }).map(x => [])",
      "    )",
      "    .map(val => fn(...val));"
    ],
    "description": "Creates an array of elements, ungrouping the elements in an array produced by [zip](#zip) and applying the provided function.\n\n返回一个数组，把[zip](#zip)产生的数组元素的分组拆解掉，并对每个元素应用给定的函数。\n\nUse `Math.max.apply()` to get the longest subarray in the array, `Array.prototype.map()` to make each element an array.\nUse `Array.prototype.reduce()` and `Array.prototype.forEach()` to map grouped values to individual arrays.\nUse `Array.prototype.map()` and the spread operator (`...`) to apply `fn` to each individual group of elements.\n\n使用`Math.max.apply()`获取数组中最长的子数组，使用`Array.prototype.map()`来把每个元素转为一个数组。使用`Array.prototype.reduce()` 和 `Array.prototype.forEach()`来把映射出来的分组的值列表分解到单独的数组列表中。使用`Array.prototype.map()`和展开操作符(`...`)来对分组中每个元素列表应用函数`fn`.\n"
  },
  "URLJoin": {
    "prefix": "30s_URLJoin",
    "body": [
      "const URLJoin = (...args) =>",
      "  args",
      "    .join('/')",
      "    .replace(/[\\/]+/g, '/')",
      "    .replace(/^(.+):\\//, '$1://')",
      "    .replace(/^file:/, 'file:/')",
      "    .replace(/\\/(\\?|&|#[^!])/g, '$1')",
      "    .replace(/\\?/g, '&')",
      "    .replace('&', '?');"
    ],
    "description": "Joins all given URL segments together, then normalizes the resulting URL.\n\n把所有给出的URL片段连结起来，然后把结果URL标准化。\n\nUse `String.prototype.join('/')` to combine URL segments, then a series of `String.prototype.replace()` calls with various regexps to normalize the resulting URL (remove double slashes, add proper slashes for protocol, remove slashes before parameters, combine parameters with `'&'` and normalize first parameter delimiter).\n\n使用`String.prototype.join('/')`来连结URL片段，然后用一系列传入正则表达式调用的`String.prototype.replace()`来标准化结果URL（删除连续的双斜线，为协议添加合适的可选符号`|`，删除参数前面的可选符号`|`，用`&`连结参数列表，然后标准化第一个参数分隔符）。\n"
  },
  "UUIDGeneratorBrowser": {
    "prefix": "30s_UUIDGeneratorBrowser",
    "body": [
      "const UUIDGeneratorBrowser = () =>",
      "  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>",
      "    (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)",
      "  );"
    ],
    "description": "Generates a UUID in a browser.\n\n在浏览器环境中生成一个UUID。\n\nUse `crypto` API to generate a UUID, compliant with [RFC4122](https://www.ietf.org/rfc/rfc4122.txt) version 4.\n\n使用`crypto`来生成遵从[RFC4122](https://www.ietf.org/rfc/rfc4122.txt)第4版本的UUID。\n"
  },
  "UUIDGeneratorNode": {
    "prefix": "30s_UUIDGeneratorNode",
    "body": [
      "const crypto = require('crypto');",
      "const UUIDGeneratorNode = () =>",
      "  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>",
      "    (c ^ (crypto.randomBytes(1)[0] & (15 >> (c / 4)))).toString(16)",
      "  );"
    ],
    "description": "Generates a UUID in Node.JS.\n\n在Node.JS中生成一个UUID。\n\nUse `crypto` API to generate a UUID, compliant with [RFC4122](https://www.ietf.org/rfc/rfc4122.txt) version 4.\n\n使用`crypto`API来生成一个UUID，兼容[RFC4122](https://www.ietf.org/rfc/rfc4122.txt)版本4。\n"
  },
  "validateNumber": {
    "prefix": "30s_validateNumber",
    "body": [
      "const validateNumber = n => !isNaN(parseFloat(n)) && isFinite(n) && Number(n) == n;"
    ],
    "description": "Returns `true` if the given value is a number, `false` otherwise.\n\n如果给出的值是一个数字则返回`true`，否则返回`false`。\n\nUse `!isNaN()` in combination with `parseFloat()` to check if the argument is a number.\nUse `isFinite()` to check if the number is finite.\nUse `Number()` to check if the coercion holds.\n\n使用`!isNaN()`和`parseFloat()`来检查这个参数是否是一个数字。使用`isFinite()`来检查这个数字是否是有穷尽的。使用`Number()`来检查是否强制持有（是否为转换后为`Number`？）。\n"
  },
  "vectorDistance": {
    "prefix": "30s_vectorDistance",
    "body": [
      "const vectorDistance = (...coords) => {",
      "  let pointLength = Math.trunc(coords.length / 2);",
      "  let sum = coords",
      "    .slice(0, pointLength)",
      "    .reduce((acc, val, i) => acc + Math.pow(val - coords[pointLength + i], 2), 0);",
      "  return Math.sqrt(sum);",
      "};"
    ],
    "description": "Returns the distance between two vectors.\n\nUse `Array.prototype.reduce()`, `Math.pow()` and `Math.sqrt()` to calculate the Euclidean distance between two vectors.\n"
  },
  "weightedSample": {
    "prefix": "30s_weightedSample",
    "body": [
      "const weightedSample = (arr, weights) => {",
      "  let roll = Math.random();",
      "  return arr[",
      "    weights",
      "      .reduce((acc, w, i) => (i === 0 ? [w] : [...acc, acc[acc.length - 1] + w]), [])",
      "      .findIndex((v, i, s) => roll >= (i === 0 ? 0 : s[i - 1]) && roll < v)",
      "  ];",
      "};"
    ],
    "description": "Returns a random element from an array, using the provided `weights` as the probabilities for each element.\n\nUse `Array.prototype.reduce()` to create an array of partial sums for each value in `weights`.\nUse `Math.random()` to generate a random number and `Array.prototype.findIndex()` to find the correct index based on the array previously produced.\nFinally, return the element of `arr` with the produced index.\n\n"
  },
  "when": {
    "prefix": "30s_when",
    "body": [
      "const when = (pred, whenTrue) => x => (pred(x) ? whenTrue(x) : x);"
    ],
    "description": "Tests a value, `x`, against a predicate function. If `true`, return `fn(x)`. Else, return `x`. \n\n用断言函数测试一个值`x`。如果结构为`true`则返回`fn(x)`,否则返回`x`。\n\nReturn a function expecting a single value, `x`, that returns the appropriate value based on `pred`.\n\n返回一个接收一个值`x`，并且根据`pred`决定合适的返回值的函数。\n"
  },
  "without": {
    "prefix": "30s_without",
    "body": [
      "const without = (arr, ...args) => arr.filter(v => !args.includes(v));"
    ],
    "description": "Filters out the elements of an array, that have one of the specified values.\n\n过滤掉包含某个指定的值列表中的值的数组元素。\n\nUse `Array.prototype.filter()` to create an array excluding(using `!Array.includes()`) all given values.\n\n使用`Array.prototype.filter()`来构造一个排除(使用`!Array.includes()`)所有给出的值后的数组。\n\n_(For a snippet that mutates the original array see [`pull`](#pull))_\n\n_(改变原始数组的版本，参加 [`pull`](#pull))_\n"
  },
  "words": {
    "prefix": "30s_words",
    "body": [
      "const words = (str, pattern = /[^a-zA-Z-]+/) => str.split(pattern).filter(Boolean);"
    ],
    "description": "Converts a given string into an array of words.\n\n把给出的字符串转换为一个单词列表。\n\nUse `String.prototype.split()` with a supplied pattern (defaults to non-alpha as a regexp) to convert to an array of strings. Use `Array.prototype.filter()` to remove any empty strings.\nOmit the second argument to use the default regexp.\n\n使用`String.prototype.split()`和给出的标识（默认是一个非字母正则表达式）来转换一个字符串数组。使用`Array.prototype.filter()`删除掉所有的空字符串。如果不传第二个参数，则使用默认的正则表达式。\n"
  },
  "xProd": {
    "prefix": "30s_xProd",
    "body": [
      "const xProd = (a, b) => a.reduce((acc, x) => acc.concat(b.map(y => [x, y])), []);"
    ],
    "description": "Creates a new array out of the two supplied by creating each possible pair from the arrays.\n\n通过创建数组列表中每个可能的元素组合，从给出的两个数组创建一个新列表。\n\nUse `Array.prototype.reduce()`, `Array.prototype.map()` and `Array.prototype.concat()` to produce every possible pair from the elements of the two arrays and save them in an array.\n\n使用`Array.prototype.reduce()`, `Array.prototype.map()` 和 `Array.prototype.concat()`来从给定的两个数组中产生每种可能的元素组合，然后把它们保存到一个数组中。\n"
  },
  "yesNo": {
    "prefix": "30s_yesNo",
    "body": [
      "const yesNo = (val, def = false) =>",
      "  /^(y|yes)$/i.test(val) ? true : /^(n|no)$/i.test(val) ? false : def;"
    ],
    "description": "Returns `true` if the string is `y`/`yes` or `false` if the string is `n`/`no`.\n\n如果一个字符串是`y`/`yes`则返回`true`，或者是`n`/`no`则返回`false`。\n\nUse `RegExp.test()` to check if the string evaluates to `y/yes` or `n/no`.\nOmit the second argument, `def` to set the default answer as `no`.\n\n使用`RegExp.test()`来检查这个字符串是否是`y/yes`或者`n/no`。如果不传第二个参数`def`，则把默认的回答设置为`no`。\n"
  },
  "yesterday": {
    "prefix": "30s_yesterday",
    "body": [
      "const yesterday = () => {",
      "  let t = new Date();",
      "  t.setDate(t.getDate() - 1);",
      "  return t.toISOString().split('T')[0];",
      "};"
    ],
    "description": "Results in a string representation of yesterday's date.\n\nUse `new Date()` to get the current date, decrement by one using `Date.getDate()` and set the value to the result using `Date.setDate()`.\nUse `Date.prototype.toISOString()` to return a string in `yyyy-mm-dd` format.\n"
  },
  "zip": {
    "prefix": "30s_zip",
    "body": [
      "const zip = (...arrays) => {",
      "  const maxLength = Math.max(...arrays.map(x => x.length));",
      "  return Array.from({ length: maxLength }).map((_, i) => {",
      "    return Array.from({ length: arrays.length }, (_, k) => arrays[k][i]);",
      "  });",
      "};"
    ],
    "description": "Creates an array of elements, grouped based on the position in the original arrays.\n\n创建一个基于原始数组列表中位置来分组的元素列表的数组（二维数组）。\n\nUse `Math.max.apply()` to get the longest array in the arguments.\nCreates an array with that length as return value and use `Array.from()` with a map-function to create an array of grouped elements.\nIf lengths of the argument-arrays vary, `undefined` is used where no value could be found.\n\n使用`Math.max.apply()`来获取参数列表中最长的数组。用它的长度建立一个数组作为返回结果，使用`Array.from()`和一个映射函数来创建一个分组的元素列表的数组。\n"
  },
  "zipObject": {
    "prefix": "30s_zipObject",
    "body": [
      "const zipObject = (props, values) =>",
      "  props.reduce((obj, prop, index) => ((obj[prop] = values[index]), obj), {});"
    ],
    "description": "Given an array of valid property identifiers and an array of values, return an object associating the properties to the values.\n\n给定一个可用的属性名称数组和一个值的数组，返回一个把属性名称和值关联起来的对象。\n\nSince an object can have undefined values but not undefined property pointers, the array of properties is used to decide the structure of the resulting object using `Array.prototype.reduce()`.\n\n由于一个对象可能有undefined的值但属性指针不是undefined，属性名称列表配合`Array.prototype.reduce()`使用，用来确定结果对象的结构。\n"
  },
  "zipWith": {
    "prefix": "30s_zipWith",
    "body": [
      "const zipWith = (...array) => {",
      "  const fn = typeof array[array.length - 1] === 'function' ? array.pop() : undefined;",
      "  return Array.from({ length: Math.max(...array.map(a => a.length)) }, (_, i) =>",
      "    fn ? fn(...array.map(a => a[i])) : array.map(a => a[i])",
      "  );",
      "};"
    ],
    "description": "Creates an array of elements, grouped based on the position in the original arrays and using function as the last value to specify how grouped values should be combined.\n\n创建一个元素列表的数组（二维数组），根据元素数组列表中的位置分组，并使用最后一个值来给定一个函数，用来指定分组的值该如何被结合到一起。\n\nCheck if the last argument provided is a function.\nUse `Math.max()` to get the longest array in the arguments.\nCreates an array with that length as return value and use `Array.from()` with a map-function to create an array of grouped elements.\nIf lengths of the argument-arrays vary, `undefined` is used where no value could be found.\nThe function is invoked with the elements of each group `(...group)`.\n\n检查给出的最后一个参数是不是一个函数。使用`Math.max()`来获取参数中最长的数组。用这个长度创建一个数组作为返回值，用`Array.from()`和一个映射函数来创建分组后元素列表的数组。如果给出的参数数组列表的长度是不同的，没有值的位置使用`undefined`来补充。这个给出的函数对每一个分组`(...group)`中的元素列表都应用。\n"
  }
}